package wrapper

// #include <flint/flint.h>
import "C"
import "unsafe"

func IncreaseRefCounter(node GraphNode) {
	var flintNode *C.FGraphNode = node.ref
	flintNode.reference_counter = C.size_t(flintNode.reference_counter + C.size_t(1))
}

func DecreaseRefCounter(node GraphNode) {
	var flintNode *C.FGraphNode = node.ref
	// make sure it does not underflow!
	if uint64(flintNode.reference_counter) == 0 {
		return // FIXME: throw error instead?
	}
	flintNode.reference_counter = C.size_t(flintNode.reference_counter - C.size_t(1))
}

func SetRefCounter(node GraphNode, value uint) {
	var flintNode *C.FGraphNode = node.ref
	flintNode.reference_counter = C.size_t(value)
}

/*
FreeGraph Decrements [node]'s "reference_counter" and deallocates the node and its corresponding data, if the counter reaches 0.
If the node is deallocated, the same process is repeated with its predecessors.
So you can safely connect nodes multiple times and have only to free the leaf nodes (i.e. the results),
without caring about cross-reference, since those are handled by the reference counting system.
*/
func FreeGraph(node GraphNode) {
	C.fFreeGraph(node.ref)
}

/*
SyncMemory flushes all GPU data to the CPU.
[ExecuteGraph] does not guarantee that memory is present on the cpu (it may be kept on the GPU for performance reasons).
This method enforces all GPU data to be flushed to the CPU (but never executes the node!).
Also see [CalculateResult].
*/
func SyncMemory(node GraphNode) {
	C.fSyncMemory(node.ref)
	//res := C.fSyncMemory(node.ref)
	//return Result{resultRef: res}
}

/*
OptimizeMemory frees all parental data (operand nodes of the operation of this node) and transforming this node to a storage nodes
if no gradient variables are present in this node and result data is present (i.e. it has been executed).
If you call this function manually please make sure to call [IncreaseRefCounter] of the parents if you want to keep their handles,
since this function may decrease their counter and free them.
*/
func OptimizeMemory(node GraphNode) GraphNode {
	var flintNode *C.FGraphNode = C.fOptimizeMemory(node.ref)
	return GraphNode{ref: flintNode}
}

/*
Serialize the data and shape of the node and returns an array of bytes, in which the serialized data will be written.
*/
func Serialize(node GraphNode) ([]byte, error) {
	var size C.size_t
	ptr, errno := C.fserialize(node.ref, &size)
	defer C.free(unsafe.Pointer(ptr))
	if ptr == nil {
		return []byte{}, buildError(errno)
	}
	return C.GoBytes(unsafe.Pointer(ptr), C.int(size)), nil
}

/*
Deserialize un-serializes data generated by [Serialize].
The size of the data is stored in itself, therefore no extra parameters are needed.
*/
func Deserialize(data []byte) (GraphNode, error) {
	unsafeData := C.CBytes(data)
	defer C.free(unsafe.Pointer(unsafeData))
	// this cast is necessary as the binary data needs to be passed as char*.
	bytesRead := C.size_t(0)
	flintNode, errno := C.fdeserialize((*C.char)(unsafeData), &bytesRead)
	if flintNode == nil {
		return GraphNode{}, buildError(errno)
	}
	return GraphNode{ref: flintNode}, nil
}
