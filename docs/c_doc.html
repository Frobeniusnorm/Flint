<!DOCTYPE html>
<html>
<head>
  <title>
    Flint Documentation
  </title>
  <link rel="stylesheet" href="style.css" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
</head>

<body>

  <div id="header-bar">
    <div class="left-spaced">
      <img src="flint.png" style="width:5.2em; height:3em; display: inline-block; vertical-align: middle;" />
      <a class="item" href="index.html">About</a>
      <a class="item selected"  href="documentation.html">Documentation</a>
      <a class="item">Tutorial</a>
    </div>
  </div>
  <div id="showcase_background" style="min-height: 18em; background: linear-gradient(90deg, rgba(2,0,36,1) 0%, rgba(153,213,23,1) 0%, rgba(0,179,255,1) 100%);">
    <center style="margin-top:2em">
      <h1>
        Documentation <u>flint.h</u>
      </h1>
    </center>
  </div>
  <center>
    <div class="content" style="margin-top: -3.1em">
        <div class="card">    <span class="card_header">Overview</span></div><br /><div class="card"><span class="card_header" style="font-size:1.2em">Types</span><ul><li><a href="#s-FLogType_">enum <b>FLogType </b></a></li><li><a href="#s-FImageFormat_">enum <b>FImageFormat </b></a></li><li><a href="#s-FType_">enum <b>FType </b></a></li><li><a href="#s-FOperation_">struct <b>FOperation </b></a></li><li><a href="#s-FResultData_">struct <b>FResultData </b></a></li><li><a href="#s-FGraphNode_">struct <b>FGraphNode </b></a></li><li><a href="#s-FStore_">struct <b>FStore </b></a></li></ul><span class="card_header" style="font-size:1.2em">Functions</span><ul><li><a href="#s-flintInit_int_backends_">void <b>flintInit</b>(int backends)</a></li><li><a href="#s-flintInit_cpu__">void <b>flintInit_cpu</b>()</a></li><li><a href="#s-flintInit_gpu__">void <b>flintInit_gpu</b>()</a></li><li><a href="#s-flintInitializedBackends__">int <b>flintInitializedBackends</b>()</a></li><li><a href="#s-flintCleanup__">void <b>flintCleanup</b>()</a></li><li><a href="#s-flintCleanup_cpu__">void <b>flintCleanup_cpu</b>()</a></li><li><a href="#s-flintCleanup_gpu__">void <b>flintCleanup_gpu</b>()</a></li><li><a href="#s-fSetLoggingLevel_int_">void <b>fSetLoggingLevel</b>(int)</a></li><li><a href="#s-flogging_FLogType_type__const_char_*msg_">void <b>flogging</b>(FLogType type, const char *msg)</a></li><li><a href="#s-fEnableEagerExecution__">void <b>fEnableEagerExecution</b>()</a></li><li><a href="#s-fDisableEagerExecution__">void <b>fDisableEagerExecution</b>()</a></li><li><a href="#s-fIsEagerExecution__">int <b>fIsEagerExecution</b>()</a></li><li><a href="#s-fCreateGraph_const_void_*data__const_int_num_entries__________________________const_FType_data_type__const_size_t_*shape__________________________const_int_dimensions_">FGraphNode <b>*fCreateGraph</b>(const void *data, const int num_entries,
                         const FType data_type, const size_t *shape,
                         const int dimensions)</a></li><li><a href="#s-fconstant_i_const_int_value__const_size_t_*shape_________________________const_int_dimensions_">FGraphNode <b>*fconstant_i</b>(const int value, const size_t *shape,
                        const int dimensions)</a></li><li><a href="#s-fconstant_l_const_long_value__const_size_t_*shape_________________________const_int_dimensions_">FGraphNode <b>*fconstant_l</b>(const long value, const size_t *shape,
                        const int dimensions)</a></li><li><a href="#s-fconstant_f_const_float_value__const_size_t_*shape_________________________const_int_dimensions_">FGraphNode <b>*fconstant_f</b>(const float value, const size_t *shape,
                        const int dimensions)</a></li><li><a href="#s-fconstant_d_const_double_value__const_size_t_*shape_________________________const_int_dimensions_">FGraphNode <b>*fconstant_d</b>(const double value, const size_t *shape,
                        const int dimensions)</a></li><li><a href="#s-frandom_const_size_t_*shape__const_int_dimensions_">FGraphNode <b>*frandom</b>(const size_t *shape, const int dimensions)</a></li><li><a href="#s-fFreeGraph_FGraphNode_*graph_">void <b>fFreeGraph</b>(FGraphNode *graph)</a></li><li><a href="#s-fCopyGraph_const_FGraphNode_*graph_">FGraphNode <b>*fCopyGraph</b>(const FGraphNode *graph)</a></li><li><a href="#s-fExecuteGraph_FGraphNode_*node_">FGraphNode <b>*fExecuteGraph</b>(FGraphNode *node)</a></li><li><a href="#s-fExecuteGraph_cpu_FGraphNode_*node_">FGraphNode <b>*fExecuteGraph_cpu</b>(FGraphNode *node)</a></li><li><a href="#s-fExecuteGraph_gpu_FGraphNode_*node_">FGraphNode <b>*fExecuteGraph_gpu</b>(FGraphNode *node)</a></li><li><a href="#s-fExecuteGraph_cpu_eagerly_FGraphNode_*node_">FGraphNode <b>*fExecuteGraph_cpu_eagerly</b>(FGraphNode *node)</a></li><li><a href="#s-fExecuteGraph_gpu_eagerly_FGraphNode_*node_">FGraphNode <b>*fExecuteGraph_gpu_eagerly</b>(FGraphNode *node)</a></li><li><a href="#s-fSyncMemory_FGraphNode_*data_">FResultData <b>*fSyncMemory</b>(FGraphNode *data)</a></li><li><a href="#s-fCalculateResult_FGraphNode_*node_">FGraphNode <b>*fCalculateResult</b>(FGraphNode *node)</a></li><li><a href="#s-fCalculateGradient_FGraphNode_*outputfct__const_FGraphNode_*dx_">FGraphNode <b>*fCalculateGradient</b>(FGraphNode *outputfct, const FGraphNode *dx)</a></li><li><a href="#s-fMarkGradientVariable_FGraphNode_*node_">void <b>fMarkGradientVariable</b>(FGraphNode *node)</a></li><li><a href="#s-fUnmarkGradientVariable_FGraphNode_*node_">void <b>fUnmarkGradientVariable</b>(FGraphNode *node)</a></li><li><a href="#s-fOptimizeMemory_FGraphNode_*node_">FGraphNode <b>*fOptimizeMemory</b>(FGraphNode *node)</a></li><li><a href="#s-fserialize_FGraphNode_*node__size_t_*bytes_written_">char <b>*fserialize</b>(FGraphNode *node, size_t *bytes_written)</a></li><li><a href="#s-fdeserialize_char_*data_">FGraphNode <b>*fdeserialize</b>(char *data)</a></li><li><a href="#s-fload_image_const_char_*path_">FGraphNode <b>*fload_image</b>(const char *path)</a></li><li><a href="#s-fadd_g_FGraphNode_*a__FGraphNode_*b_">FGraphNode <b>*fadd_g</b>(FGraphNode *a, FGraphNode *b)</a></li><li><a href="#s-fsub_g_FGraphNode_*a__FGraphNode_*b_">FGraphNode <b>*fsub_g</b>(FGraphNode *a, FGraphNode *b)</a></li><li><a href="#s-fdiv_g_FGraphNode_*a__FGraphNode_*b_">FGraphNode <b>*fdiv_g</b>(FGraphNode *a, FGraphNode *b)</a></li><li><a href="#s-fmul_g_FGraphNode_*a__FGraphNode_*b_">FGraphNode <b>*fmul_g</b>(FGraphNode *a, FGraphNode *b)</a></li><li><a href="#s-fpow_g_FGraphNode_*a__FGraphNode_*b_">FGraphNode <b>*fpow_g</b>(FGraphNode *a, FGraphNode *b)</a></li><li><a href="#s-fadd_ci_FGraphNode_*a__const_int_b_">FGraphNode <b>*fadd_ci</b>(FGraphNode *a, const int b)</a></li><li><a href="#s-fadd_cl_FGraphNode_*a__const_long_b_">FGraphNode <b>*fadd_cl</b>(FGraphNode *a, const long b)</a></li><li><a href="#s-fadd_cf_FGraphNode_*a__const_float_b_">FGraphNode <b>*fadd_cf</b>(FGraphNode *a, const float b)</a></li><li><a href="#s-fadd_cd_FGraphNode_*a__const_double_b_">FGraphNode <b>*fadd_cd</b>(FGraphNode *a, const double b)</a></li><li><a href="#s-fsub_ci_FGraphNode_*a__const_int_b_">FGraphNode <b>*fsub_ci</b>(FGraphNode *a, const int b)</a></li><li><a href="#s-fsub_cl_FGraphNode_*a__const_long_b_">FGraphNode <b>*fsub_cl</b>(FGraphNode *a, const long b)</a></li><li><a href="#s-fsub_cf_FGraphNode_*a__const_float_b_">FGraphNode <b>*fsub_cf</b>(FGraphNode *a, const float b)</a></li><li><a href="#s-fsub_cd_FGraphNode_*a__const_double_b_">FGraphNode <b>*fsub_cd</b>(FGraphNode *a, const double b)</a></li><li><a href="#s-fsub_ici_const_int_a__FGraphNode_*b_">FGraphNode <b>*fsub_ici</b>(const int a, FGraphNode *b)</a></li><li><a href="#s-fsub_icl_const_long_a__FGraphNode_*b_">FGraphNode <b>*fsub_icl</b>(const long a, FGraphNode *b)</a></li><li><a href="#s-fsub_icf_const_float_a__FGraphNode_*b_">FGraphNode <b>*fsub_icf</b>(const float a, FGraphNode *b)</a></li><li><a href="#s-fsub_icd_const_double_a__FGraphNode_*b_">FGraphNode <b>*fsub_icd</b>(const double a, FGraphNode *b)</a></li><li><a href="#s-fdiv_ci_FGraphNode_*a__const_int_b_">FGraphNode <b>*fdiv_ci</b>(FGraphNode *a, const int b)</a></li><li><a href="#s-fdiv_cl_FGraphNode_*a__const_long_b_">FGraphNode <b>*fdiv_cl</b>(FGraphNode *a, const long b)</a></li><li><a href="#s-fdiv_cf_FGraphNode_*a__const_float_b_">FGraphNode <b>*fdiv_cf</b>(FGraphNode *a, const float b)</a></li><li><a href="#s-fdiv_cd_FGraphNode_*a__const_double_b_">FGraphNode <b>*fdiv_cd</b>(FGraphNode *a, const double b)</a></li><li><a href="#s-fdiv_ici_const_int_a__FGraphNode_*b_">FGraphNode <b>*fdiv_ici</b>(const int a, FGraphNode *b)</a></li><li><a href="#s-fdiv_icl_const_long_a__FGraphNode_*b_">FGraphNode <b>*fdiv_icl</b>(const long a, FGraphNode *b)</a></li><li><a href="#s-fdiv_icf_const_float_a__FGraphNode_*b_">FGraphNode <b>*fdiv_icf</b>(const float a, FGraphNode *b)</a></li><li><a href="#s-fdiv_icd_const_double_a__FGraphNode_*b_">FGraphNode <b>*fdiv_icd</b>(const double a, FGraphNode *b)</a></li><li><a href="#s-fmul_ci_FGraphNode_*a__const_int_b_">FGraphNode <b>*fmul_ci</b>(FGraphNode *a, const int b)</a></li><li><a href="#s-fmul_cl_FGraphNode_*a__const_long_b_">FGraphNode <b>*fmul_cl</b>(FGraphNode *a, const long b)</a></li><li><a href="#s-fmul_cf_FGraphNode_*a__const_float_b_">FGraphNode <b>*fmul_cf</b>(FGraphNode *a, const float b)</a></li><li><a href="#s-fmul_cd_FGraphNode_*a__const_double_b_">FGraphNode <b>*fmul_cd</b>(FGraphNode *a, const double b)</a></li><li><a href="#s-fpow_ci_FGraphNode_*a__const_int_b_">FGraphNode <b>*fpow_ci</b>(FGraphNode *a, const int b)</a></li><li><a href="#s-fpow_cl_FGraphNode_*a__const_long_b_">FGraphNode <b>*fpow_cl</b>(FGraphNode *a, const long b)</a></li><li><a href="#s-fpow_cf_FGraphNode_*a__const_float_b_">FGraphNode <b>*fpow_cf</b>(FGraphNode *a, const float b)</a></li><li><a href="#s-fpow_cd_FGraphNode_*a__const_double_b_">FGraphNode <b>*fpow_cd</b>(FGraphNode *a, const double b)</a></li><li><a href="#s-flog_FGraphNode_*a_">FGraphNode <b>*flog</b>(FGraphNode *a)</a></li><li><a href="#s-flog2_FGraphNode_*a_">FGraphNode <b>*flog2</b>(FGraphNode *a)</a></li><li><a href="#s-flog10_FGraphNode_*a_">FGraphNode <b>*flog10</b>(FGraphNode *a)</a></li><li><a href="#s-fsin_FGraphNode_*a_">FGraphNode <b>*fsin</b>(FGraphNode *a)</a></li><li><a href="#s-fsqrt_g_FGraphNode_*a_">FGraphNode <b>*fsqrt_g</b>(FGraphNode *a)</a></li><li><a href="#s-fcos_FGraphNode_*a_">FGraphNode <b>*fcos</b>(FGraphNode *a)</a></li><li><a href="#s-ftan_FGraphNode_*a_">FGraphNode <b>*ftan</b>(FGraphNode *a)</a></li><li><a href="#s-fasin_FGraphNode_*a_">FGraphNode <b>*fasin</b>(FGraphNode *a)</a></li><li><a href="#s-facos_FGraphNode_*a_">FGraphNode <b>*facos</b>(FGraphNode *a)</a></li><li><a href="#s-fatan_FGraphNode_*a_">FGraphNode <b>*fatan</b>(FGraphNode *a)</a></li><li><a href="#s-fneg_FGraphNode_*a_">FGraphNode <b>*fneg</b>(FGraphNode *a)</a></li><li><a href="#s-fsign_FGraphNode_*a_">FGraphNode <b>*fsign</b>(FGraphNode *a)</a></li><li><a href="#s-feven_FGraphNode_*a_">FGraphNode <b>*feven</b>(FGraphNode *a)</a></li><li><a href="#s-fless_g_FGraphNode_*a__FGraphNode_*b_">FGraphNode <b>*fless_g</b>(FGraphNode *a, FGraphNode *b)</a></li><li><a href="#s-fgreater_g_FGraphNode_*a__FGraphNode_*b_">FGraphNode <b>*fgreater_g</b>(FGraphNode *a, FGraphNode *b)</a></li><li><a href="#s-fequal_g_FGraphNode_*a__FGraphNode_*b_">FGraphNode <b>*fequal_g</b>(FGraphNode *a, FGraphNode *b)</a></li><li><a href="#s-fless_ci_FGraphNode_*a__const_int_b_">FGraphNode <b>*fless_ci</b>(FGraphNode *a, const int b)</a></li><li><a href="#s-fless_cl_FGraphNode_*a__const_long_b_">FGraphNode <b>*fless_cl</b>(FGraphNode *a, const long b)</a></li><li><a href="#s-fless_cf_FGraphNode_*a__const_float_b_">FGraphNode <b>*fless_cf</b>(FGraphNode *a, const float b)</a></li><li><a href="#s-fless_cd_FGraphNode_*a__const_double_b_">FGraphNode <b>*fless_cd</b>(FGraphNode *a, const double b)</a></li><li><a href="#s-fgreater_ci_FGraphNode_*a__const_int_b_">FGraphNode <b>*fgreater_ci</b>(FGraphNode *a, const int b)</a></li><li><a href="#s-fgreater_cl_FGraphNode_*a__const_long_b_">FGraphNode <b>*fgreater_cl</b>(FGraphNode *a, const long b)</a></li><li><a href="#s-fgreater_cf_FGraphNode_*a__const_float_b_">FGraphNode <b>*fgreater_cf</b>(FGraphNode *a, const float b)</a></li><li><a href="#s-fgreater_cd_FGraphNode_*a__const_double_b_">FGraphNode <b>*fgreater_cd</b>(FGraphNode *a, const double b)</a></li><li><a href="#s-fequal_ci_FGraphNode_*a__const_int_b_">FGraphNode <b>*fequal_ci</b>(FGraphNode *a, const int b)</a></li><li><a href="#s-fequal_cl_FGraphNode_*a__const_long_b_">FGraphNode <b>*fequal_cl</b>(FGraphNode *a, const long b)</a></li><li><a href="#s-fequal_cf_FGraphNode_*a__const_float_b_">FGraphNode <b>*fequal_cf</b>(FGraphNode *a, const float b)</a></li><li><a href="#s-fequal_cd_FGraphNode_*a__const_double_b_">FGraphNode <b>*fequal_cd</b>(FGraphNode *a, const double b)</a></li><li><a href="#s-fmatmul_FGraphNode_*a__FGraphNode_*b_">FGraphNode <b>*fmatmul</b>(FGraphNode *a, FGraphNode *b)</a></li><li><a href="#s-fflatten_FGraphNode_*a_">FGraphNode <b>*fflatten</b>(FGraphNode *a)</a></li><li><a href="#s-fflatten_dimension_FGraphNode_*a__int_dimension_">FGraphNode <b>*fflatten_dimension</b>(FGraphNode *a, int dimension)</a></li><li><a href="#s-fconvert_FGraphNode_*a__FType_newtype_">FGraphNode <b>*fconvert</b>(FGraphNode *a, FType newtype)</a></li><li><a href="#s-freshape_FGraphNode_*a__size_t_*newshape__int_dimensions_">FGraphNode <b>*freshape</b>(FGraphNode *a, size_t *newshape, int dimensions)</a></li><li><a href="#s-fmin_g_FGraphNode_*a__FGraphNode_*b_">FGraphNode <b>*fmin_g</b>(FGraphNode *a, FGraphNode *b)</a></li><li><a href="#s-fmin_ci_FGraphNode_*a__const_int_b_">FGraphNode <b>*fmin_ci</b>(FGraphNode *a, const int b)</a></li><li><a href="#s-fmin_cl_FGraphNode_*a__const_long_b_">FGraphNode <b>*fmin_cl</b>(FGraphNode *a, const long b)</a></li><li><a href="#s-fmin_cf_FGraphNode_*a__const_float_b_">FGraphNode <b>*fmin_cf</b>(FGraphNode *a, const float b)</a></li><li><a href="#s-fmin_cd_FGraphNode_*a__const_double_b_">FGraphNode <b>*fmin_cd</b>(FGraphNode *a, const double b)</a></li><li><a href="#s-fmax_g_FGraphNode_*a__FGraphNode_*b_">FGraphNode <b>*fmax_g</b>(FGraphNode *a, FGraphNode *b)</a></li><li><a href="#s-fmax_ci_FGraphNode_*a__const_int_b_">FGraphNode <b>*fmax_ci</b>(FGraphNode *a, const int b)</a></li><li><a href="#s-fmax_cl_FGraphNode_*a__const_long_b_">FGraphNode <b>*fmax_cl</b>(FGraphNode *a, const long b)</a></li><li><a href="#s-fmax_cf_FGraphNode_*a__const_float_b_">FGraphNode <b>*fmax_cf</b>(FGraphNode *a, const float b)</a></li><li><a href="#s-fmax_cd_FGraphNode_*a__const_double_b_">FGraphNode <b>*fmax_cd</b>(FGraphNode *a, const double b)</a></li><li><a href="#s-freduce_sum_FGraphNode_*a__const_int_dimension_">FGraphNode <b>*freduce_sum</b>(FGraphNode *a, const int dimension)</a></li><li><a href="#s-freduce_mul_FGraphNode_*a__const_int_dimension_">FGraphNode <b>*freduce_mul</b>(FGraphNode *a, const int dimension)</a></li><li><a href="#s-fslice_FGraphNode_*a__const_long_*start__const_long_*end_">FGraphNode <b>*fslice</b>(FGraphNode *a, const long *start, const long *end)</a></li><li><a href="#s-fslice_step_FGraphNode_*a__const_long_*start__const_long_*end_________________________const_long_*step_">FGraphNode <b>*fslice_step</b>(FGraphNode *a, const long *start, const long *end,
                        const long *step)</a></li><li><a href="#s-fextend_FGraphNode_*a__const_size_t_*new_shape_____________________const_size_t_*insert_at_">FGraphNode <b>*fextend</b>(FGraphNode *a, const size_t *new_shape,
                    const size_t *insert_at)</a></li><li><a href="#s-fextend_step_FGraphNode_*a__const_size_t_*new_shape__________________________const_size_t_*insert_at__const_long_*step_size_">FGraphNode <b>*fextend_step</b>(FGraphNode *a, const size_t *new_shape,
                         const size_t *insert_at, const long *step_size)</a></li><li><a href="#s-fabs_g_FGraphNode_*a_">FGraphNode <b>*fabs_g</b>(FGraphNode *a)</a></li><li><a href="#s-frepeat_FGraphNode_*a__int_*repititions_">FGraphNode <b>*frepeat</b>(FGraphNode *a, int *repititions)</a></li><li><a href="#s-ftranspose_FGraphNode_*a__int_*transpositions_">FGraphNode <b>*ftranspose</b>(FGraphNode *a, int *transpositions)</a></li><li><a href="#s-fconvolve_FGraphNode_*a__FGraphNode_*kernel__unsigned_int_*steps_">FGraphNode <b>*fconvolve</b>(FGraphNode *a, FGraphNode *kernel, unsigned int *steps)</a></li><li><a href="#s-fslide_FGraphNode_*a__FGraphNode_*kernel__unsigned_int_*steps_">FGraphNode <b>*fslide</b>(FGraphNode *a, FGraphNode *kernel, unsigned int *steps)</a></li></ul></div>
        <div style="display: block; height: 2em;"></div>
        <div class="card attention_box" style="padding: 20px 15px; background-color: #f4bfbf;">
          The C-Backend has a memory management system optimized for easy usage in C++, which makes it a little bit weird in C.
          It uses reference counting for all nodes, but the initial counter is set to 0 and increased when connected to another node.
          <pre class="code" style="padding: 2px; margin: 5px; font-size: 1em"><pre class="card code" style="margin: 5px;">
FGraphNode *gn1 = fCreateGraph(...); <span style="color: #D0D0D0">// counter is <span style="color: #30F0FF">0</span></span>
FGraphNode *gn2 = fCreateGraph(...); <span style="color: #D0D0D0">// counter is <span style="color: #30F0FF">0</span></span>
FGraphNode *gn3 = fadd(gn1, gn2); <span style="color: #D0D0D0">// counter of gn3 is <span style="color: #30F0FF">0</span>, of gn1 is <span style="color: #30F0FF">1</span> and of gn2 is <span style="color: #30F0FF">1</span></span></pre>
          </pre>
          The reason for that is that a call to <pre class="inline_code">fFreeGraph</pre> does not decrease the reference counter but frees the node when it is already 0.
          If a node is freed the method can be recursively called for all its parents, in the example if one calls <pre class="inline_code">fFreeGraph(gn3)</pre>, <pre class="inline_code">gn1</pre> and <pre class="inline_code">gn2</pre> are freed too. This is important when calling <pre class="inline_code">fOptimizeMemory</pre> for e.g. <pre class="inline_code">gn3</pre>, which is allowed to free parental informations when no longer needed.
          Since in that case <pre class="inline_code">gn1</pre> and <pre class="inline_code">gn2</pre> have a reference counter of 1 depending on <pre class="inline_code">gn3</pre> they could no longer be used after a call to <pre class="inline_code">fOptimizeMemory(gn3)</pre>, to prevent that you have to artifically manipulate the reference counter for nodes in such a context by calling <pre class="inline_code">gn1->reference_counter++</pre>.
        </div>
        <div style="display: block; height: 2em;"></div>
        <div id="s-flintInit_int_backends_"></div><div class="card"><pre class="card_header_code">void <b>flintInit</b>(int backends)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Initializes the cpu and the gpu backends. These functions are already
 implicitly called by the execution functions if necessary. The method allows
 disabling of the gpu backend (by passing <pre class="inline_code">FLINT_BACKEND_ONLY_CPU</pre>), disabling
 of the cpu backend (by passing <pre class="inline_code">FLINT_BACKEND_BOTH</pre>), initializing both
 backends explicitly (by passing <pre class="inline_code">FLINT_BACKEND_BOTH</pre>, which is recommended,
 since Flint is then allowed to choose the framework with heuristics). Only
 use those functions if you...<ul><li>...want to explicitly decide where and when the initialization should take
      place
</li><li>...want to only start one backend</li></ul> </div></div><div style="display: block; height: 2em;"></div>
<div id="s-flintInit_cpu__"></div><div class="card"><pre class="card_header_code">void <b>flintInit_cpu</b>()</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Don't call this function explicitly if you intent to use Flint normally. Use
 <pre class="inline_code">flintInit</pre> </div></div><div style="display: block; height: 2em;"></div>
<div id="s-flintInit_gpu__"></div><div class="card"><pre class="card_header_code">void <b>flintInit_gpu</b>()</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Don't call this function explicitly if you intent to use Flint normally. Use
 <pre class="inline_code">flintInit</pre> </div></div><div style="display: block; height: 2em;"></div>
<div id="s-flintInitializedBackends__"></div><div class="card"><pre class="card_header_code">int <b>flintInitializedBackends</b>()</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Returns an integer containing the Backend information bitwise.
 See constants <pre class="inline_code">FLINT_BACKEND_ONLY_CPU</pre>, <pre class="inline_code">FLINT_BACKEND_ONLY_GPU</pre> and
 <pre class="inline_code">FLINT_BACKEND_BOTH</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div id="s-flintCleanup__"></div><div class="card"><pre class="card_header_code">void <b>flintCleanup</b>()</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Deallocates any resourced allocated by the corresponding backends.
This method calls the other two (following) which are only executed if the
framework was initialized, else they do nothing. </div></div><div style="display: block; height: 2em;"></div>
<div id="s-flintCleanup_cpu__"></div><div class="card"><pre class="card_header_code">void <b>flintCleanup_cpu</b>()</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Deallocates any resourced allocated by the cpu backend, if it was
 initialized, else it does nothing. </div></div><div style="display: block; height: 2em;"></div>
<div id="s-flintCleanup_gpu__"></div><div class="card"><pre class="card_header_code">void <b>flintCleanup_gpu</b>()</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Deallocates any resourced allocated by the gpu backend, if it was
 initialized, else it does nothing. </div></div><div style="display: block; height: 2em;"></div>
<div id="s-fSetLoggingLevel_int_"></div><div class="card"><pre class="card_header_code">void <b>fSetLoggingLevel</b>(int)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Sets the logging level of the framework. Adjust this for debugging purposes,
 or if you release software in which Flint is contained.
 See also: <pre class="inline_code">flogging</pre>, <pre class="inline_code">FLogType</pre><div style="display:block; height: 0.5em"></div>
 Levels:<ul><li>0: No logging
</li><li>1: Only <pre class="inline_code">F_ERROR</pre>
</li><li>2: Logging level <pre class="inline_code">F_WARNING</pre> (should be used for production)
</li><li>3: Logging level <pre class="inline_code">F_INFO</pre> (for developement)
</li><li>4: Logging level <pre class="inline_code">F_VERBOSE</pre> (for library developement)
</li><li>5: Logging level <pre class="inline_code">F_DEBUG</pre> (when a bug in the library has been found)</li></ul>
</div></div><div style="display: block; height: 2em;"></div>
<div id="s-FLogType_"></div><div class="card"><pre class="card_header_code">enum <b>FLogType </b></pre></div>
<br />
<div class="card"><div style="padding: 5px;">
 See also: <pre class="inline_code">flogging</pre>, <pre class="inline_code">FLogType</pre><ul><li><pre class="inline_code">F_DEBUG</pre> (only internal debugging informations of the framework),
</li><li><pre class="inline_code">F_VERBOSE</pre> (verbose information, may be helpful to users of the
    library),
</li><li><pre class="inline_code">F_INFO</pre> (informational data of the framework, e.g. which
    graphics card has been chosen),
</li><li><pre class="inline_code">F_ERROR</pre> (unrecoverable errors,
    generated by function calls to the framework, raises a exception
    everytime),
</li><li><pre class="inline_code">F_WARNING</pre> (probably unwanted behaviour or undefined behaviour caused
    by missuse of functions).</li></ul>
</div></div><div style="display: block; height: 2em;"></div>
<div id="s-FImageFormat_"></div><div class="card"><pre class="card_header_code">enum <b>FImageFormat </b></pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Supported Image formats for fstore_image </div></div><div style="display: block; height: 2em;"></div>
<div id="s-flogging_FLogType_type__const_char_*msg_"></div><div class="card"><pre class="card_header_code">void <b>flogging</b>(FLogType type, const char *msg)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Logs a NULL terminated string with the given logging level.
 See also: <pre class="inline_code">fSetLoggingLevel</pre> </div></div><div style="display: block; height: 2em;"></div>
<div id="s-fEnableEagerExecution__"></div><div class="card"><pre class="card_header_code">void <b>fEnableEagerExecution</b>()</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> All graph nodes that represent actual operations are after this call
 executed eagerly, i.e. they are executed during graph construction.<div style="display:block; height: 0.5em"></div>
 This may improve performance when only using the CPU backend, in any other
 case disabling eager execution should be prefered. </div></div><div style="display: block; height: 2em;"></div>
<div id="s-fDisableEagerExecution__"></div><div class="card"><pre class="card_header_code">void <b>fDisableEagerExecution</b>()</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Disable eager execution, i.e. the graph is constructed without execution of
 the nodes until a operation makes the execution of a parent graph necessary
 or the user calls <pre class="inline_code">fExecuteGraph</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div id="s-fIsEagerExecution__"></div><div class="card"><pre class="card_header_code">int <b>fIsEagerExecution</b>()</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Returns 1 if eager execution has been enabled, else 0 </div></div><div style="display: block; height: 2em;"></div>
<div id="s-FType_"></div><div class="card"><pre class="card_header_code">enum <b>FType </b></pre></div>
<br />
<div class="card"><div style="padding: 5px;"> The 4 allowed data types:<ul><li><pre class="inline_code">F_INT32</pre>(integer, 32bit)
</li><li><pre class="inline_code">F_INT64</pre>(integer, 64bit)
</li><li><pre class="inline_code">F_FLOAT32</pre> (floating point, 32bit)
</li><li><pre class="inline_code">F_FLOAT64</pre> (floating point, 64bit)</li></ul>
</div></div><div style="display: block; height: 2em;"></div>
<div id="s-FOperation_"></div><div class="card"><pre class="card_header_code">struct <b>FOperation </b></pre></div>
<br />
<div class="card"><div style="padding: 5px;">
 Describes one operation. An operation always has a shape, described by
 <pre class="inline_code">FOperation.shape</pre> which is an array of size
 <pre class="inline_code">FOperation.dimensions</pre> with each entry denoting the size of the
 corresponding dimension. <pre class="inline_code">FOperation.op_type</pre> denotes the type of
 operation, <pre class="inline_code">FOperation.data_type</pre> the type of the underlying data,
 <pre class="inline_code">FOperation.additional_data</pre> is operation specific.</div></div><div style="display: block; height: 2em;"></div>
<div id="s-FResultData_"></div><div class="card"><pre class="card_header_code">struct <b>FResultData </b></pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Stores the resulting data after an execution of <pre class="inline_code">fExecuteGraph</pre> (or implicit
 execution). The data can be found in <pre class="inline_code">FResultData.data</pre>, the datatype in
 <pre class="inline_code">FOperation.data_type</pre> of the corresponding <pre class="inline_code">FGraphNode</pre>.
 The number of entries (not number of bytes) is stored in
 <pre class="inline_code">FResultData.num_entries</pre>. The data may be consistently modified
 if...<ul><li>...the data size is changed, num_entries is equivalently updated and
      <pre class="inline_code">realloc</pre> is used and ...
</li><li>...the data was not already loaded to the gpu (i.e. the result must be the
        return value of <pre class="inline_code">fExecuteGraph_cpu</pre>)</li></ul>
</div></div><div style="display: block; height: 2em;"></div>
<div id="s-FGraphNode_"></div><div class="card"><pre class="card_header_code">struct <b>FGraphNode </b></pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Describes one node in the Graph. Stores the corresponding operation in
 <pre class="inline_code">FGraphNode.operation</pre>, an array of predecessors (the arguments of
 the operation) in <pre class="inline_code">FGraphNode.predecessors</pre>, its size in
 <pre class="inline_code">FGraphNode.num_predecessor</pre> and the reference counter in
 <pre class="inline_code">FGraphNode.reference_counter</pre>. Do not modify any parameter by yourself,
 since the framework manages them, but you can read the data and structure
 from them. The nodes are allocated by the operation functions, they and their
 members should neither be manually created, edited or freed except by the
 corresponding flint methods. </div></div><div style="display: block; height: 2em;"></div>
<div id="s-FStore_"></div><div class="card"><pre class="card_header_code">struct <b>FStore </b></pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Result of an call to <pre class="inline_code">fCreateGraph</pre>, see <pre class="inline_code">FResultData</pre>.
 Data of this Operation may not be changed manually when using a GPU Backend.
</div></div><div style="display: block; height: 2em;"></div>
<div id="s-fCreateGraph_const_void_*data__const_int_num_entries__________________________const_FType_data_type__const_size_t_*shape__________________________const_int_dimensions_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*fCreateGraph</b>(const void *data, const int num_entries,
                         const FType data_type, const size_t *shape,
                         const int dimensions)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"><ul><li><pre class="inline_code">data</pre>: pointer to the flattened data array that should be loaded into
   the node
</li><li><pre class="inline_code">num_entries</pre>: the number of elements (NOT BYTES!) that should
   be loaded
</li><li><pre class="inline_code">data_type</pre>: the datatype of <pre class="inline_code">data</pre>
</li><li><pre class="inline_code">shape</pre>: an array of size <pre class="inline_code">dimensions</pre>, each entry describing the
   size of the corresponding dimension. Make sure, <pre class="inline_code">data</pre> is at least as
   large as the product of all entries in <pre class="inline_code">shape</pre>
</li><li><pre class="inline_code">dimensions</pre>: the number of dimensions
</li></ul>
 Creates a Graph with a single store instruction, the data is
 copied to intern memory, so after return of the function, <pre class="inline_code">data</pre> and <pre class="inline_code">shape</pre>
 may be deleted. </div></div><div style="display: block; height: 2em;"></div>
<div id="s-fconstant_i_const_int_value__const_size_t_*shape_________________________const_int_dimensions_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*fconstant_i</b>(const int value, const size_t *shape,
                        const int dimensions)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Creates a tensor that contains the single given values in all entries<div style="display:block; height: 0.5em"></div><ul><li><pre class="inline_code">value</pre>: the value this tensor should consist of
</li><li><pre class="inline_code">shape</pre>: an array of size <pre class="inline_code">dimensions</pre>, each entry describing the size
    of the corresponding dimension.
</li><li><pre class="inline_code">dimensions</pre>: the number of dimensions</li></ul>
</div></div><div style="display: block; height: 2em;"></div>
<div id="s-fconstant_l_const_long_value__const_size_t_*shape_________________________const_int_dimensions_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*fconstant_l</b>(const long value, const size_t *shape,
                        const int dimensions)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Creates a tensor that contains the single given values in all entries<div style="display:block; height: 0.5em"></div><ul><li><pre class="inline_code">value</pre>: the value this tensor should consist of
</li><li><pre class="inline_code">shape</pre>: an array of size <pre class="inline_code">dimensions</pre>, each entry describing the size
    of the corresponding dimension.
</li><li><pre class="inline_code">dimensions</pre>: the number of dimensions</li></ul>
</div></div><div style="display: block; height: 2em;"></div>
<div id="s-fconstant_f_const_float_value__const_size_t_*shape_________________________const_int_dimensions_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*fconstant_f</b>(const float value, const size_t *shape,
                        const int dimensions)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Creates a tensor that contains the single given values in all entries<div style="display:block; height: 0.5em"></div><ul><li><pre class="inline_code">value</pre>: the value this tensor should consist of
</li><li><pre class="inline_code">shape</pre>: an array of size <pre class="inline_code">dimensions</pre>, each entry describing the size
    of the corresponding dimension.
</li><li><pre class="inline_code">dimensions</pre>: the number of dimensions</li></ul>
</div></div><div style="display: block; height: 2em;"></div>
<div id="s-fconstant_d_const_double_value__const_size_t_*shape_________________________const_int_dimensions_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*fconstant_d</b>(const double value, const size_t *shape,
                        const int dimensions)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Creates a tensor that contains the single given values in all entries<div style="display:block; height: 0.5em"></div><ul><li><pre class="inline_code">value</pre>: the value this tensor should consist of
</li><li><pre class="inline_code">shape</pre>: an array of size <pre class="inline_code">dimensions</pre>, each entry describing the size
    of the corresponding dimension.
</li><li><pre class="inline_code">dimensions</pre>: the number of dimensions</li></ul>
</div></div><div style="display: block; height: 2em;"></div>
<div id="s-frandom_const_size_t_*shape__const_int_dimensions_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*frandom</b>(const size_t *shape, const int dimensions)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Creates a tensor that contains randomly distributed values in the range of
 [0, 1)<div style="display:block; height: 0.5em"></div><ul><li><pre class="inline_code">shape</pre>: an array of size <pre class="inline_code">dimensions</pre>, each entry describing the size
    of the corresponding dimension.
</li><li><pre class="inline_code">dimensions</pre>: the number of dimensions</li></ul>
</div></div><div style="display: block; height: 2em;"></div>
<div id="s-fFreeGraph_FGraphNode_*graph_"></div><div class="card"><pre class="card_header_code">void <b>fFreeGraph</b>(FGraphNode *graph)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Decrements <pre class="inline_code">FGraphNode.reference_counter</pre> of <pre class="inline_code">graph</pre> (for reference
 counting) and deallocates the node and its corresponding data, if the counter
 becomes 0. If the node is deallocated, the same process is repeated with its
 predecessors. So you can safely connect nodes multiple times and have only to
 free the leaf nodes (i.e. the results), without caring about cross-reference,
 since those are handled by the reference counting system.</div></div><div style="display: block; height: 2em;"></div>
<div id="s-fCopyGraph_const_FGraphNode_*graph_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*fCopyGraph</b>(const FGraphNode *graph)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Copies the graph node, the corresponding operation and additional data and
 the predecessors (their <pre class="inline_code">FGraphNode.reference_counter</pre> is
 incremented) </div></div><div style="display: block; height: 2em;"></div>
<div id="s-fExecuteGraph_FGraphNode_*node_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*fExecuteGraph</b>(FGraphNode *node)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Executes the graph node operations from all yet to be executed predecessors
 to <pre class="inline_code">node</pre> and returns a node with a <pre class="inline_code">FResultData</pre> operation in
 which the resulting data is stored.<div style="display:block; height: 0.5em"></div>
 If the graph is executed by the GPU
 backend, a opencl kernel containing all selected operations (the nodes
 operation and those indirect parent operations which were not yet
 executed) are compiled and executed. The kernels are cashed, so it improves
 the performance of a program if the same graph-structures are reused (not
 necessary the same nodes, but the same combination of nodes), since then the
 backend can reuse already compiled kernels. The GPU backend is allowed to
 keep the Result data on the GPU without synchronizing it (so the generated
 <pre class="inline_code">FResultData</pre> may not have a <pre class="inline_code">data</pre> member!). To force synchronization use
 <pre class="inline_code">fSyncMemory</pre> or replace the call with <pre class="inline_code">fCalculateResult</pre>.<div style="display:block; height: 0.5em"></div>
 If the CPU backend is chosen, it
 does not matter, since every operation is executed independently (here eager
 execution might be faster).<div style="display:block; height: 0.5em"></div>
 The backend is selected by the framework if both
 are initialized, else the one that is initialized will be chosen. If both are
 uninitialized, both will be initialized prior to execution. If eager
 exeuction is enabled each node will be executed eagerly upon construction or
 with this method.<div style="display:block; height: 0.5em"></div>
 Also see <pre class="inline_code">fEnableEagerExecution</pre>, <pre class="inline_code">fSyncMemory</pre></div></div><div style="display: block; height: 2em;"></div>
<div id="s-fExecuteGraph_cpu_FGraphNode_*node_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*fExecuteGraph_cpu</b>(FGraphNode *node)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Executes the graph node operations from all yet to be executed predecessors
 to <pre class="inline_code">node</pre> and returns a node with a <pre class="inline_code">FResultData</pre> operation in
 which the resulting data is stored. </div></div><div style="display: block; height: 2em;"></div>
<div id="s-fExecuteGraph_gpu_FGraphNode_*node_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*fExecuteGraph_gpu</b>(FGraphNode *node)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Executes the graph node operations from all yet to be executed predecessors
 to <pre class="inline_code">node</pre> and returns a node with a <pre class="inline_code">FResultData</pre> operation in
 which the resulting data is stored. For the GPU
 backend, a opencl kernel containing all selected operations (the nodes
 operation and those indirect parent operations which were not yet executed)
 are compiled and executed. The kernels are cashed, so it improves the
 performance of a program if the same graph-structures are reused (not
 necessary the same nodes, but the same combination of nodes), since then the
 backend can reuse already compiled kernels. </div></div><div style="display: block; height: 2em;"></div>
<div id="s-fExecuteGraph_cpu_eagerly_FGraphNode_*node_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*fExecuteGraph_cpu_eagerly</b>(FGraphNode *node)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Executes the graph node directly and assumes that predecessor data has
 already been computed. Uses the CPU backend. Mainly used by helper functions
 of the framework, only use it if you now what you are doing.<div style="display:block; height: 0.5em"></div>
 Also see <pre class="inline_code">fEnableEagerExecution</pre>, <pre class="inline_code">fExecuteGraph_cpu</pre> and <pre class="inline_code">fExecuteGraph</pre></div></div><div style="display: block; height: 2em;"></div>
<div id="s-fExecuteGraph_gpu_eagerly_FGraphNode_*node_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*fExecuteGraph_gpu_eagerly</b>(FGraphNode *node)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Executes the graph node directly and assumes that predecessor data has
 already been computed. Uses the GPU backend where for each operation and
 parameter type combination one eager kernel will be computed. Mainly used by
 helper functions of the framework, only use it if you now what you are doing.<div style="display:block; height: 0.5em"></div>
  Also see <pre class="inline_code">fEnableEagerExecution</pre>, <pre class="inline_code">fExecuteGraph_gpu</pre> and <pre class="inline_code">fExecuteGraph</pre></div></div><div style="display: block; height: 2em;"></div>
<div id="s-fSyncMemory_FGraphNode_*data_"></div><div class="card"><pre class="card_header_code">FResultData <b>*fSyncMemory</b>(FGraphNode *data)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> <pre class="inline_code">fExecuteGraoh</pre> does not guarantee that memory is present on the cpu (it may
 be kept on the GPU for performance reasons). This method enforces all GPU
 data to be flushed to the CPU (but never executes the node!).<div style="display:block; height: 0.5em"></div>
 Also see <pre class="inline_code">fCalculateResult</pre>
</div></div><div style="display: block; height: 2em;"></div>
<div id="s-fCalculateResult_FGraphNode_*node_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*fCalculateResult</b>(FGraphNode *node)</pre></div>
<br />
<div class="card"><div style="padding: 5px;">
 Convenience Method that first execute <pre class="inline_code">fExecuteGraph</pre> and then <pre class="inline_code">fSyncMemory</pre>
 on the node.<div style="display:block; height: 0.5em"></div>
 It represents execution with one of both backends and additional memory
 synchronizing for the gpu framework.
</div></div><div style="display: block; height: 2em;"></div>
<div id="s-fCalculateGradient_FGraphNode_*outputfct__const_FGraphNode_*dx_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*fCalculateGradient</b>(FGraphNode *outputfct, const FGraphNode *dx)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Calculates the overall gradient of an output node to a variable.
 The variable must be marked as a gradient variable, see
 <pre class="inline_code">fMarkGradientVariable</pre>.<div style="display:block; height: 0.5em"></div><ul><li><pre class="inline_code">outputfct</pre>: the Node which represents the chain of functions of which
    the gradient is to be computed.
</li><li><pre class="inline_code">dx</pre>: the variable for which outputfct is derived for</li></ul>
</div></div><div style="display: block; height: 2em;"></div>
<div id="s-fMarkGradientVariable_FGraphNode_*node_"></div><div class="card"><pre class="card_header_code">void <b>fMarkGradientVariable</b>(FGraphNode *node)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Marks this node as a node for which a gradient might be calculated later.
 It is only possible to calculate the gradient for this node (as a derivative)
 in operations that occur AFTER a call to this method (all subsequent
 operations will have a remark that enlists this node as a possible gradient
 variable, to enable less memory usage and faster gradient calculation).
</div></div><div style="display: block; height: 2em;"></div>
<div id="s-fUnmarkGradientVariable_FGraphNode_*node_"></div><div class="card"><pre class="card_header_code">void <b>fUnmarkGradientVariable</b>(FGraphNode *node)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Removes the gradient mark (ans subsequent memory overhead) for this node.
 After a call to this method no subsequent gradient calculations with this
 node as a derivative will be possible.
</div></div><div style="display: block; height: 2em;"></div>
<div id="s-fOptimizeMemory_FGraphNode_*node_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*fOptimizeMemory</b>(FGraphNode *node)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Optimizes memory by freeing all parental data (operand nodes of the
 operation of this node) and transforming this node to a storage nodes
 if no gradient variables are present in this node and result data is
 present (i.e. it has been executed).
 If you call this function manually please make sure to increase the
 <pre class="inline_code">reference_counter</pre> of the parents if you want to keep their handles,
 since this function may decrease their counter and free them.
 The C++ framework does this automatically.
</div></div><div style="display: block; height: 2em;"></div>
<div id="s-fserialize_FGraphNode_*node__size_t_*bytes_written_"></div><div class="card"><pre class="card_header_code">char <b>*fserialize</b>(FGraphNode *node, size_t *bytes_written)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Serializes the data and shape of the node and returns a array of chars in
 which the serialized data will be written. The returned array is allocated on
 the systems heap with <pre class="inline_code">malloc</pre>, so you have to free it after you are done
 with it. The number of bytes that the returned array has is written into the
 memory <pre class="inline_code">bytes_written</pre> points to if it is not a nullptr. If the node doesn't
 have result data, it is executed first.
</div></div><div style="display: block; height: 2em;"></div>
<div id="s-fdeserialize_char_*data_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*fdeserialize</b>(char *data)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Unserializes data generated by <pre class="inline_code">fserialize</pre>.
 The size of the data is stored in itself, therefor no extra parameters are
 needed. Internally calls <pre class="inline_code">fCreateGraph</pre>.
</div></div><div style="display: block; height: 2em;"></div>
<div id="s-fload_image_const_char_*path_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*fload_image</b>(const char *path)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Loads an image from the given path.
 The image will be stored in floating point data and the shape will be h, w, c
 where w is the width, h is the height and c are the chanels.
 Supported formats include png, jpeg, bmp, gif, hdr ... essentially everything
 stb_image supports
</div></div><div style="display: block; height: 2em;"></div>
<div id="s-fadd_g_FGraphNode_*a__FGraphNode_*b_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*fadd_g</b>(FGraphNode *a, FGraphNode *b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Elementwise addition of <pre class="inline_code">a</pre> and <pre class="inline_code">b</pre>, i.e. <pre class="inline_code">a[i] + b[i]</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div id="s-fsub_g_FGraphNode_*a__FGraphNode_*b_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*fsub_g</b>(FGraphNode *a, FGraphNode *b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Elementwise substraction of <pre class="inline_code">a</pre> and <pre class="inline_code">b</pre>, i.e. <pre class="inline_code">a[i] - b[i]</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div id="s-fdiv_g_FGraphNode_*a__FGraphNode_*b_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*fdiv_g</b>(FGraphNode *a, FGraphNode *b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Elementwise division of <pre class="inline_code">a</pre> and <pre class="inline_code">b</pre>, i.e. <pre class="inline_code">a[i] / b[i]</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div id="s-fmul_g_FGraphNode_*a__FGraphNode_*b_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*fmul_g</b>(FGraphNode *a, FGraphNode *b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Elementwise multiplication of <pre class="inline_code">a</pre> and <pre class="inline_code">b</pre>, i.e. <pre class="inline_code">a[i] * b[i]</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div id="s-fpow_g_FGraphNode_*a__FGraphNode_*b_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*fpow_g</b>(FGraphNode *a, FGraphNode *b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Elementwise power of <pre class="inline_code">a</pre> and <pre class="inline_code">b</pre>, i.e. <pre class="inline_code">pow(a[i], b[i])</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div id="s-fadd_ci_FGraphNode_*a__const_int_b_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*fadd_ci</b>(FGraphNode *a, const int b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Elementwise addition of a and b, i.e. <pre class="inline_code">a[i] + b</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div id="s-fadd_cl_FGraphNode_*a__const_long_b_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*fadd_cl</b>(FGraphNode *a, const long b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Elementwise addition of a and b, i.e. <pre class="inline_code">a[i] + b</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div id="s-fadd_cf_FGraphNode_*a__const_float_b_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*fadd_cf</b>(FGraphNode *a, const float b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Elementwise addition of a and b, i.e. <pre class="inline_code">a[i] + b</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div id="s-fadd_cd_FGraphNode_*a__const_double_b_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*fadd_cd</b>(FGraphNode *a, const double b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Elementwise addition of a and b, i.e. <pre class="inline_code">a[i] + b</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div id="s-fsub_ci_FGraphNode_*a__const_int_b_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*fsub_ci</b>(FGraphNode *a, const int b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Elementwise subtraction of a and b, i.e. <pre class="inline_code">a[i] - b</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div id="s-fsub_cl_FGraphNode_*a__const_long_b_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*fsub_cl</b>(FGraphNode *a, const long b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Elementwise subtraction of a and b, i.e. <pre class="inline_code">a[i] - b</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div id="s-fsub_cf_FGraphNode_*a__const_float_b_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*fsub_cf</b>(FGraphNode *a, const float b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Elementwise subtraction of a and b, i.e. <pre class="inline_code">a[i] - b</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div id="s-fsub_cd_FGraphNode_*a__const_double_b_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*fsub_cd</b>(FGraphNode *a, const double b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Elementwise subtraction of a and b, i.e. <pre class="inline_code">a[i] - b</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div id="s-fsub_ici_const_int_a__FGraphNode_*b_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*fsub_ici</b>(const int a, FGraphNode *b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Elementwise subtraction of a and b, i.e. <pre class="inline_code">a - b[i]</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div id="s-fsub_icl_const_long_a__FGraphNode_*b_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*fsub_icl</b>(const long a, FGraphNode *b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Elementwise subtraction of a and b, i.e. <pre class="inline_code">a - b[i]</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div id="s-fsub_icf_const_float_a__FGraphNode_*b_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*fsub_icf</b>(const float a, FGraphNode *b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Elementwise subtraction of a and b, i.e. <pre class="inline_code">a - b[i]</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div id="s-fsub_icd_const_double_a__FGraphNode_*b_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*fsub_icd</b>(const double a, FGraphNode *b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Elementwise subtraction of a and b, i.e. <pre class="inline_code">a - b[i]</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div id="s-fdiv_ci_FGraphNode_*a__const_int_b_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*fdiv_ci</b>(FGraphNode *a, const int b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Elementwise division of a and b, i.e. <pre class="inline_code">a[i] / b</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div id="s-fdiv_cl_FGraphNode_*a__const_long_b_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*fdiv_cl</b>(FGraphNode *a, const long b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Elementwise division of a and b, i.e. <pre class="inline_code">a[i] / b</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div id="s-fdiv_cf_FGraphNode_*a__const_float_b_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*fdiv_cf</b>(FGraphNode *a, const float b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Elementwise division of a and b, i.e. <pre class="inline_code">a[i] / b</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div id="s-fdiv_cd_FGraphNode_*a__const_double_b_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*fdiv_cd</b>(FGraphNode *a, const double b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Elementwise division of a and b, i.e. <pre class="inline_code">a[i] / b</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div id="s-fdiv_ici_const_int_a__FGraphNode_*b_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*fdiv_ici</b>(const int a, FGraphNode *b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Elementwise division of a and b, i.e. <pre class="inline_code">a / b[i]</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div id="s-fdiv_icl_const_long_a__FGraphNode_*b_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*fdiv_icl</b>(const long a, FGraphNode *b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Elementwise division of a and b, i.e. <pre class="inline_code">a / b[i]</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div id="s-fdiv_icf_const_float_a__FGraphNode_*b_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*fdiv_icf</b>(const float a, FGraphNode *b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Elementwise division of a and b, i.e. <pre class="inline_code">a / b[i]</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div id="s-fdiv_icd_const_double_a__FGraphNode_*b_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*fdiv_icd</b>(const double a, FGraphNode *b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Elementwise division of a and b, i.e. <pre class="inline_code">a / b[i]</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div id="s-fmul_ci_FGraphNode_*a__const_int_b_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*fmul_ci</b>(FGraphNode *a, const int b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Elementwise multiplication of a and b, i.e. <pre class="inline_code">a[i] * b</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div id="s-fmul_cl_FGraphNode_*a__const_long_b_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*fmul_cl</b>(FGraphNode *a, const long b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Elementwise multiplication of a and b, i.e. <pre class="inline_code">a[i] * b</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div id="s-fmul_cf_FGraphNode_*a__const_float_b_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*fmul_cf</b>(FGraphNode *a, const float b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Elementwise multiplication of a and b, i.e. <pre class="inline_code">a[i] * b</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div id="s-fmul_cd_FGraphNode_*a__const_double_b_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*fmul_cd</b>(FGraphNode *a, const double b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Elementwise multiplication of a and b, i.e. <pre class="inline_code">a[i] * b</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div id="s-fpow_ci_FGraphNode_*a__const_int_b_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*fpow_ci</b>(FGraphNode *a, const int b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Takes the elementwise power of a to b, i.e. <pre class="inline_code">pow(a[i], b)</pre>.</div></div><div style="display: block; height: 2em;"></div>
<div id="s-fpow_cl_FGraphNode_*a__const_long_b_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*fpow_cl</b>(FGraphNode *a, const long b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Takes the elementwise power of a to b, i.e. <pre class="inline_code">pow(a[i], b)</pre>.</div></div><div style="display: block; height: 2em;"></div>
<div id="s-fpow_cf_FGraphNode_*a__const_float_b_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*fpow_cf</b>(FGraphNode *a, const float b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Takes the elementwise power of a to b, i.e. <pre class="inline_code">pow(a[i], b)</pre>.</div></div><div style="display: block; height: 2em;"></div>
<div id="s-fpow_cd_FGraphNode_*a__const_double_b_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*fpow_cd</b>(FGraphNode *a, const double b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Takes the elementwise power of a to b, i.e. <pre class="inline_code">pow(a[i], b)</pre>.</div></div><div style="display: block; height: 2em;"></div>
<div id="s-flog_FGraphNode_*a_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*flog</b>(FGraphNode *a)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Takes the elementwise natural logarithm of <pre class="inline_code">a</pre> </div></div><div style="display: block; height: 2em;"></div>
<div id="s-flog2_FGraphNode_*a_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*flog2</b>(FGraphNode *a)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Takes the elementwise logarithm of <pre class="inline_code">a</pre> to the basis of 2 </div></div><div style="display: block; height: 2em;"></div>
<div id="s-flog10_FGraphNode_*a_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*flog10</b>(FGraphNode *a)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Takes the elementwise logarithm of <pre class="inline_code">a</pre> to the basis of 10 </div></div><div style="display: block; height: 2em;"></div>
<div id="s-fsin_FGraphNode_*a_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*fsin</b>(FGraphNode *a)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Takes the elementwise sinus of a </div></div><div style="display: block; height: 2em;"></div>
<div id="s-fsqrt_g_FGraphNode_*a_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*fsqrt_g</b>(FGraphNode *a)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Takes the elementwise square root of a </div></div><div style="display: block; height: 2em;"></div>
<div id="s-fcos_FGraphNode_*a_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*fcos</b>(FGraphNode *a)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Takes the elementwise cosinus of a </div></div><div style="display: block; height: 2em;"></div>
<div id="s-ftan_FGraphNode_*a_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*ftan</b>(FGraphNode *a)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Takes the elementwise tangents of a </div></div><div style="display: block; height: 2em;"></div>
<div id="s-fasin_FGraphNode_*a_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*fasin</b>(FGraphNode *a)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Takes the elementwise inverse sinus of a </div></div><div style="display: block; height: 2em;"></div>
<div id="s-facos_FGraphNode_*a_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*facos</b>(FGraphNode *a)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Takes the elementwise inverse cosinus of a </div></div><div style="display: block; height: 2em;"></div>
<div id="s-fatan_FGraphNode_*a_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*fatan</b>(FGraphNode *a)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Takes the elementwise inverse tangents of a </div></div><div style="display: block; height: 2em;"></div>
<div id="s-fneg_FGraphNode_*a_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*fneg</b>(FGraphNode *a)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Negates the elements of <pre class="inline_code">a</pre>, i.e. <pre class="inline_code">-a[i]</pre> </div></div><div style="display: block; height: 2em;"></div>
<div id="s-fsign_FGraphNode_*a_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*fsign</b>(FGraphNode *a)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Returns a <pre class="inline_code">F_INT32</pre> tensor x with the shape of a with <pre class="inline_code">x[i] = 1</pre> if <pre class="inline_code">a[i] &gt;=
 0</pre> else <pre class="inline_code">x[i] = -1</pre>. <pre class="inline_code">a</pre> needs to have a integer data type.</div></div><div style="display: block; height: 2em;"></div>
<div id="s-feven_FGraphNode_*a_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*feven</b>(FGraphNode *a)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Returns a <pre class="inline_code">F_INT32</pre> tensor <pre class="inline_code">x</pre> with the shape of <pre class="inline_code">a</pre> with <pre class="inline_code">x[i] = 1</pre> if
 <pre class="inline_code">a[i] % 2 = 0</pre> else <pre class="inline_code">x[i] = 0</pre>.
</div></div><div style="display: block; height: 2em;"></div>
<div id="s-fless_g_FGraphNode_*a__FGraphNode_*b_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*fless_g</b>(FGraphNode *a, FGraphNode *b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Compares two tensors elementwise by <pre class="inline_code">a &lt; b</pre> and returns a 0,1 <pre class="inline_code">F_INT32</pre>
 Tensor. <pre class="inline_code">0</pre> denotes that <pre class="inline_code">a &gt;= b</pre>, <pre class="inline_code">1</pre> that <pre class="inline_code">a &lt; b</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div id="s-fgreater_g_FGraphNode_*a__FGraphNode_*b_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*fgreater_g</b>(FGraphNode *a, FGraphNode *b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Compares two tensors elementwise by <pre class="inline_code">a &gt; b</pre> and returns a 0,1 <pre class="inline_code">F_INT32</pre>
 Tensor. </div></div><div style="display: block; height: 2em;"></div>
<div id="s-fequal_g_FGraphNode_*a__FGraphNode_*b_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*fequal_g</b>(FGraphNode *a, FGraphNode *b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Compares two tensors elementwise by <pre class="inline_code">a = b</pre><pre class="inline_code"> and returns a 0,1 </pre>F_INT32<pre class="inline_code">
 Tensor. </pre>0<pre class="inline_code"> denotes that </pre>a &lt;= b<pre class="inline_code">, </pre>1<pre class="inline_code"> that </pre>a &gt; b<pre class="inline_code">.</pre></div></div><div style="display: block; height: 2em;"></div>
<div id="s-fless_ci_FGraphNode_*a__const_int_b_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*fless_ci</b>(FGraphNode *a, const int b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Compares a tensor and a constant elementwise by <pre class="inline_code">a &lt; b</pre> and returns a 0,1
 <pre class="inline_code">INT32</pre> Tensor. See <pre class="inline_code">fless_g</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div id="s-fless_cl_FGraphNode_*a__const_long_b_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*fless_cl</b>(FGraphNode *a, const long b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Compares a tensor and a constant elementwise by <pre class="inline_code">a &lt; b</pre> and returns a 0,1
 <pre class="inline_code">INT32</pre> Tensor. See <pre class="inline_code">fless_g</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div id="s-fless_cf_FGraphNode_*a__const_float_b_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*fless_cf</b>(FGraphNode *a, const float b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Compares a tensor and a constant elementwise by <pre class="inline_code">a &lt; b</pre> and returns a 0,1
 <pre class="inline_code">INT32</pre> Tensor. See <pre class="inline_code">fless_g</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div id="s-fless_cd_FGraphNode_*a__const_double_b_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*fless_cd</b>(FGraphNode *a, const double b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Compares a tensor and a constant elementwise by <pre class="inline_code">a &lt; b</pre> and returns a 0,1
 <pre class="inline_code">INT32</pre> Tensor. See <pre class="inline_code">fless_g</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div id="s-fgreater_ci_FGraphNode_*a__const_int_b_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*fgreater_ci</b>(FGraphNode *a, const int b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Compares a tensor and a constant elementwise by <pre class="inline_code">a &gt; b</pre> and returns a 0,1
 <pre class="inline_code">INT32</pre> Tensor. See <pre class="inline_code">fgreater_g</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div id="s-fgreater_cl_FGraphNode_*a__const_long_b_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*fgreater_cl</b>(FGraphNode *a, const long b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Compares a tensor and a constant elementwise by <pre class="inline_code">a &gt; b</pre> and returns a 0,1
 <pre class="inline_code">INT32</pre> Tensor. See <pre class="inline_code">fgreater_g</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div id="s-fgreater_cf_FGraphNode_*a__const_float_b_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*fgreater_cf</b>(FGraphNode *a, const float b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Compares a tensor and a constant elementwise by <pre class="inline_code">a &gt; b</pre> and returns a 0,1
 <pre class="inline_code">INT32</pre> Tensor. See <pre class="inline_code">fgreater_g</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div id="s-fgreater_cd_FGraphNode_*a__const_double_b_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*fgreater_cd</b>(FGraphNode *a, const double b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Compares a tensor and a constant elementwise by <pre class="inline_code">a &gt; b</pre> and returns a 0,1
 <pre class="inline_code">INT32</pre> Tensor. See <pre class="inline_code">fgreater_g</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div id="s-fequal_ci_FGraphNode_*a__const_int_b_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*fequal_ci</b>(FGraphNode *a, const int b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Compares a tensor and a constant elementwise by <pre class="inline_code">a = b</pre> and returns a 0,1
 <pre class="inline_code">INT32</pre> Tensor. See <pre class="inline_code">fequal_g</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div id="s-fequal_cl_FGraphNode_*a__const_long_b_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*fequal_cl</b>(FGraphNode *a, const long b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Compares a tensor and a constant elementwise by <pre class="inline_code">a = b</pre> and returns a 0,1
 <pre class="inline_code">INT32</pre> Tensor. See <pre class="inline_code">fequal_g</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div id="s-fequal_cf_FGraphNode_*a__const_float_b_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*fequal_cf</b>(FGraphNode *a, const float b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Compares a tensor and a constant elementwise by <pre class="inline_code">a = b</pre> and returns a 0,1
 <pre class="inline_code">INT32</pre> Tensor. See <pre class="inline_code">fequal_g</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div id="s-fequal_cd_FGraphNode_*a__const_double_b_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*fequal_cd</b>(FGraphNode *a, const double b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Compares a tensor and a constant elementwise by <pre class="inline_code">a = b</pre> and returns a 0,1
 <pre class="inline_code">INT32</pre> Tensor. See <pre class="inline_code">fequal_g</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div id="s-fmatmul_FGraphNode_*a__FGraphNode_*b_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*fmatmul</b>(FGraphNode *a, FGraphNode *b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Carries out matrix multiplication on the last two dimensions of the tensors.<div style="display:block; height: 0.5em"></div>
 E.g. a matrix multiplication of two tensors with shapes <pre class="inline_code">(64, 32, 16)</pre> and
 <pre class="inline_code">(16, 24)</pre> will yield a tensor with shape <pre class="inline_code">(64, 32, 24)</pre>.<div style="display:block; height: 0.5em"></div>
 Since for one entry of the
 tensor multiple other previous entries are needed, the operand tensors need
 to be executed first. Therefor the method will implicitly (or eagerly)
 execute the two parameter nodes <pre class="inline_code">a</pre> and <pre class="inline_code">b</pre> if their data is not allready
 present. </div></div><div style="display: block; height: 2em;"></div>
<div id="s-fflatten_FGraphNode_*a_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*fflatten</b>(FGraphNode *a)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Flattens the complete tensor to a tensor with one
dimension.
E.g.<pre class="inline_code">flattened([[[3, 1, 4], [2, 1, 5]], [[0, 4, 2], [4, 7, 9]]]) = [3, 1, 4, 2,
1, 5, 0, 4, 2, 4, 7, 9]</pre>.
</div></div><div style="display: block; height: 2em;"></div>
<div id="s-fflatten_dimension_FGraphNode_*a__int_dimension_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*fflatten_dimension</b>(FGraphNode *a, int dimension)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Flattens a tensor <pre class="inline_code">a</pre> with <pre class="inline_code">n</pre> dimensions along
<pre class="inline_code">dimension</pre>, resulting in a tensor with <pre class="inline_code">n-1</pre> dimensions.
Flattening a dimension will remove it from the shape of the tensor, therefor its
not possible to flatten the dimension 0.
A Tensor <pre class="inline_code">[[[3, 1, 4], [2, 1, 5]], [[0, 4, 2], [4, 7, 9]]]</pre> flattened
along dimension 1 will result in <pre class="inline_code">[[3,1,4], [2,1,5], [0,4,2], [4,7,9]]</pre>.
</div></div><div style="display: block; height: 2em;"></div>
<div id="s-fconvert_FGraphNode_*a__FType_newtype_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*fconvert</b>(FGraphNode *a, FType newtype)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Converts the data of <pre class="inline_code">a</pre> to the type given by <pre class="inline_code">newtype</pre></div></div><div style="display: block; height: 2em;"></div>
<div id="s-freshape_FGraphNode_*a__size_t_*newshape__int_dimensions_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*freshape</b>(FGraphNode *a, size_t *newshape, int dimensions)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Reshapes the underlying data of the tensor to the new shape. The product of
each dimension of the new shape must be the same as the product of the
dimensions of the previous shape (i.e. it must describe the same number of
entries of the tensor).</div></div><div style="display: block; height: 2em;"></div>
<div id="s-fmin_g_FGraphNode_*a__FGraphNode_*b_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*fmin_g</b>(FGraphNode *a, FGraphNode *b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Takes the minimum of two tensors element wise along the last dimension of
 each, i.e. <pre class="inline_code">a[i]</pre> if <pre class="inline_code">a[i] &lt; b[i]</pre> else <pre class="inline_code">b[i]</pre> </div></div><div style="display: block; height: 2em;"></div>
<div id="s-fmin_ci_FGraphNode_*a__const_int_b_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*fmin_ci</b>(FGraphNode *a, const int b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Takes the minimum of two tensors element wise along the last dimension of
 each, i.e. <pre class="inline_code">a[i]</pre> if <pre class="inline_code">a[i] &lt; b</pre> else <pre class="inline_code">b</pre> </div></div><div style="display: block; height: 2em;"></div>
<div id="s-fmin_cl_FGraphNode_*a__const_long_b_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*fmin_cl</b>(FGraphNode *a, const long b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Takes the minimum of two tensors element wise along the last dimension of
 each, i.e. <pre class="inline_code">a[i]</pre> if <pre class="inline_code">a[i] &lt; b</pre> else <pre class="inline_code">b</pre> </div></div><div style="display: block; height: 2em;"></div>
<div id="s-fmin_cf_FGraphNode_*a__const_float_b_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*fmin_cf</b>(FGraphNode *a, const float b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Takes the minimum of two tensors element wise along the last dimension of
 each, i.e. <pre class="inline_code">a[i]</pre> if <pre class="inline_code">a[i] &lt; b</pre> else <pre class="inline_code">b</pre> </div></div><div style="display: block; height: 2em;"></div>
<div id="s-fmin_cd_FGraphNode_*a__const_double_b_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*fmin_cd</b>(FGraphNode *a, const double b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Takes the minimum of two tensors element wise along the last dimension of
 each, i.e. <pre class="inline_code">a[i]</pre> if <pre class="inline_code">a[i] &lt; b</pre> else <pre class="inline_code">b</pre> </div></div><div style="display: block; height: 2em;"></div>
<div id="s-fmax_g_FGraphNode_*a__FGraphNode_*b_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*fmax_g</b>(FGraphNode *a, FGraphNode *b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Takes the maximum of two tensors element wise along the last dimension of
 each, i.e. <pre class="inline_code">a[i]</pre> if <pre class="inline_code">a[i] &gt; b[i]</pre> else <pre class="inline_code">b[i]</pre> </div></div><div style="display: block; height: 2em;"></div>
<div id="s-fmax_ci_FGraphNode_*a__const_int_b_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*fmax_ci</b>(FGraphNode *a, const int b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Takes the maximum of two tensors element wise along the last dimension of
 each, i.e. <pre class="inline_code">a[i]</pre> if <pre class="inline_code">a[i] &gt; b</pre> else <pre class="inline_code">b</pre> </div></div><div style="display: block; height: 2em;"></div>
<div id="s-fmax_cl_FGraphNode_*a__const_long_b_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*fmax_cl</b>(FGraphNode *a, const long b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Takes the maximum of two tensors element wise along the last dimension of
 each, i.e. <pre class="inline_code">a[i]</pre> if <pre class="inline_code">a[i] &gt; b</pre> else <pre class="inline_code">b</pre> </div></div><div style="display: block; height: 2em;"></div>
<div id="s-fmax_cf_FGraphNode_*a__const_float_b_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*fmax_cf</b>(FGraphNode *a, const float b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Takes the maximum of two tensors element wise along the last dimension of
 each, i.e. <pre class="inline_code">a[i]</pre> if <pre class="inline_code">a[i] &gt; b</pre> else <pre class="inline_code">b</pre> </div></div><div style="display: block; height: 2em;"></div>
<div id="s-fmax_cd_FGraphNode_*a__const_double_b_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*fmax_cd</b>(FGraphNode *a, const double b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Takes the maximum of two tensors element wise along the last dimension of
 each, i.e. <pre class="inline_code">a[i]</pre> if <pre class="inline_code">a[i] &gt; b</pre> else <pre class="inline_code">b</pre> </div></div><div style="display: block; height: 2em;"></div>
<div id="s-freduce_sum_FGraphNode_*a__const_int_dimension_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*freduce_sum</b>(FGraphNode *a, const int dimension)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Reduces one dimension of the tensor by additive folding e.g.<div style="display:block; height: 0.5em"></div>
 <pre class="inline_code">freduce_sum([[1,2,3], [4,5,6]], 0) = [5,7,9]</pre>,
 <pre class="inline_code">freduce_sum([[1,2,3], [4,5,6]], 1) = [6,15]</pre><div style="display:block; height: 0.5em"></div>
 The results of the predecessor node must be available, to
 ensure that the method may execute the parameter node. </div></div><div style="display: block; height: 2em;"></div>
<div id="s-freduce_mul_FGraphNode_*a__const_int_dimension_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*freduce_mul</b>(FGraphNode *a, const int dimension)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Reduces one dimension of the tensor by multiplicative folding e.g.<div style="display:block; height: 0.5em"></div>
 <pre class="inline_code">freduce_mul([[1,2,3], [4,5,6]], 0) = [4,10,18]</pre>,
 <pre class="inline_code">freduce_mul([[1,2,3], [4,5,6]], 1) = [6, 120]</pre><div style="display:block; height: 0.5em"></div>
 The results of the predecessor node must be available; to
 ensure that the method may execute the parameter node.</div></div><div style="display: block; height: 2em;"></div>
<div id="s-fslice_FGraphNode_*a__const_long_*start__const_long_*end_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*fslice</b>(FGraphNode *a, const long *start, const long *end)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Selects a slice of the tensor with a dimension wise start and end index.
 <pre class="inline_code">start</pre> and <pre class="inline_code">end</pre> are arrays with as many entries
 as the tensor has dimensions. They may contain negative values,
 which are then subtracted from the end of the tensor (e.g. <pre class="inline_code">-1</pre> means the
 element before the last element). <pre class="inline_code">start</pre> is inclusive and describes the
 start index of the selection per dimension and <pre class="inline_code">end</pre> describes the end index
 per dimension and is exclusive.
</div></div><div style="display: block; height: 2em;"></div>
<div id="s-fslice_step_FGraphNode_*a__const_long_*start__const_long_*end_________________________const_long_*step_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*fslice_step</b>(FGraphNode *a, const long *start, const long *end,
                        const long *step)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Selects a slice of the tensor with a dimension wise start index, end index
 and step size. <pre class="inline_code">start</pre>, <pre class="inline_code">end</pre> and <pre class="inline_code">step</pre> are arrays with as
 many entries as the tensor has dimensions. <pre class="inline_code">start</pre> and <pre class="inline_code">end</pre> may
 contain negative values, which are then subtracted from the end of the tensor
 (e.g. <pre class="inline_code">-1</pre> means the element before the last element). <pre class="inline_code">start</pre> is inclusive
 and describes the start index of the selection per dimension and <pre class="inline_code">end</pre>
 describes the end index per dimension and is exclusive. <pre class="inline_code">step</pre> contains the
 per dimension step size (e.g. <pre class="inline_code">2</pre> meaning every second element will be
 selected etc.) and may be negative as well, which reverses the traversal
 order (the first elements are selected as the last ones). For a negative step
 size, <pre class="inline_code">start &gt; end</pre> must hold (for a positive of course <pre class="inline_code">end &gt; start</pre>) for
 each dimension.
</div></div><div style="display: block; height: 2em;"></div>
<div id="s-fextend_FGraphNode_*a__const_size_t_*new_shape_____________________const_size_t_*insert_at_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*fextend</b>(FGraphNode *a, const size_t *new_shape,
                    const size_t *insert_at)</pre></div>
<br />
<div class="card"><div style="padding: 5px;">
 Creates a new tensor of zeroes with the requested shape. The original tensor
 is embedded at the given indices.<ul><li><pre class="inline_code">a</pre> original tensor which shape is to be extended
</li><li><pre class="inline_code">new_shape</pre> array of new sizes per dimension. Has <pre class="inline_code">dimension</pre> number of
    entries
</li><li><pre class="inline_code">insert_at</pre> array with indices per dimension denoting where <pre class="inline_code">a</pre> is to be
    placed in the resulting tensor</li></ul>
</div></div><div style="display: block; height: 2em;"></div>
<div id="s-fextend_step_FGraphNode_*a__const_size_t_*new_shape__________________________const_size_t_*insert_at__const_long_*step_size_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*fextend_step</b>(FGraphNode *a, const size_t *new_shape,
                         const size_t *insert_at, const long *step_size)</pre></div>
<br />
<div class="card"><div style="padding: 5px;">
 Creates a new tensor of zeroes with the requested shape. The original tensor
 is embedded at the given indices.<ul><li><pre class="inline_code">a</pre> original tensor which shape is to be extended,
</li><li><pre class="inline_code">new_shape</pre> array of new sizes per dimension. Has <pre class="inline_code">dimension</pre> number of
    entries.
</li><li><pre class="inline_code">insert_at</pre> array with indices per dimension denoting where <pre class="inline_code">a</pre> is to be
    placed in the resulting tensor. Has a value per dimension.
</li><li><pre class="inline_code">step_size</pre> allows to pull apart <pre class="inline_code">a</pre>, emplacing <pre class="inline_code">step_size[i]</pre> 0 between
    each value of <pre class="inline_code">a</pre>. Has a value per dimension.</li></ul>
</div></div><div style="display: block; height: 2em;"></div>
<div id="s-fabs_g_FGraphNode_*a_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*fabs_g</b>(FGraphNode *a)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Takes the elementwise absolute value of <pre class="inline_code">a</pre>, i.e. <pre class="inline_code">|a[i]|</pre> </div></div><div style="display: block; height: 2em;"></div>
<div id="s-frepeat_FGraphNode_*a__int_*repititions_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*frepeat</b>(FGraphNode *a, int *repititions)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Repeats dimensions of a tensor multiple times<div style="display:block; height: 0.5em"></div><ul><li><pre class="inline_code">a</pre>: the node in which dimensions are to be repeated
</li><li><pre class="inline_code">repititions</pre>: array with the same number of entries as the tensor has
    dimensions
</li></ul> e.g. <pre class="inline_code">repeat([[0,1], [2,3]], [2, 3]) = [[0,1,0,1,0,1],
 [2,3,2,3,2,3], [0,1,0,1,0,1], [2,3,2,3,2,3]]</pre>
</div></div><div style="display: block; height: 2em;"></div>
<div id="s-ftranspose_FGraphNode_*a__int_*transpositions_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*ftranspose</b>(FGraphNode *a, int *transpositions)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Transposes this tensor along multiple dimensions<div style="display:block; height: 0.5em"></div><ul><li><pre class="inline_code">a</pre>: the node which should be transposed
</li><li><pre class="inline_code">transpositions</pre>: an array with the same number of entries as the tensor
   has dimensions, which gives the perumtation of dimensions.
</li></ul> The tensor will have a resulting shape in which the size in dimension <pre class="inline_code">i</pre>
 corresponds to the former size in dimension <pre class="inline_code">transpositions[i]</pre>.
</div></div><div style="display: block; height: 2em;"></div>
<div id="s-fconvolve_FGraphNode_*a__FGraphNode_*kernel__unsigned_int_*steps_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*fconvolve</b>(FGraphNode *a, FGraphNode *kernel, unsigned int *steps)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Convolves the <pre class="inline_code">n</pre>-dimensional input tensor <pre class="inline_code">a</pre> with a <pre class="inline_code">n</pre>-dimensional filter
 kernel <pre class="inline_code">kernel</pre> and a per dimensional step size <pre class="inline_code">steps</pre> with size of <pre class="inline_code">n-1</pre>.
 It is expected that <pre class="inline_code">a</pre> and <pre class="inline_code">kernel</pre> have the same size in their last
 dimension (which will be completly reduced by the convolution). In all other
 dimensions the size of <pre class="inline_code">a</pre> should be larger or equal to the size of <pre class="inline_code">kernel</pre>.
 The <pre class="inline_code">kernel</pre> will be 'slid' over <pre class="inline_code">a</pre> in each dimension, multiplying all
 values of <pre class="inline_code">kernel</pre> with the corresponding ones in <pre class="inline_code">a</pre> and summing them up to
 a single value and moving the kernel further by the value given in <pre class="inline_code">steps</pre> in
 that corresponding dimension.<div style="display:block; height: 0.5em"></div>
 The implementation does an implicit right-padding, meaning that the kernel
 will initially be placed so that its first element is aligned to
 the first element of <pre class="inline_code">a</pre>, but it will be slid till no kernel element
 overlaps with any element of <pre class="inline_code">a</pre>, multiplying all "overlapping"
 elements with 0. If you want to mdofiy this behaviour you can use
 <pre class="inline_code">fextend</pre>, <pre class="inline_code">fslice</pre> or similar.<div style="display:block; height: 0.5em"></div>
 The resulting Tensor will therefor have a shape with dimensionality <pre class="inline_code">n - 1</pre>
 and size of <pre class="inline_code">resulting_shape[i] = 1 + (a-&gt;operation-&gt;shape[i] - 1) /
 steps[i]</pre>
</div></div><div style="display: block; height: 2em;"></div>
<div id="s-fslide_FGraphNode_*a__FGraphNode_*kernel__unsigned_int_*steps_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*fslide</b>(FGraphNode *a, FGraphNode *kernel, unsigned int *steps)</pre></div>
<br />
<div class="card"><div style="padding: 5px;">
 Slides <pre class="inline_code">kernel</pre> along <pre class="inline_code">a</pre>, multiplying it with the elements of <pre class="inline_code">a</pre> it is slid
 over. For each element all multiplied values are summed up, so that the
 result has the same shape as <pre class="inline_code">kernel</pre> (every element in the result is the
 accumulated sum of the product of that element with all elements it was slid
 over). <pre class="inline_code">kernel</pre> is initially placed so that the first element of <pre class="inline_code">a</pre> and
 the first element of <pre class="inline_code">kernel</pre> overlap. It is then moved for each dimension
 <pre class="inline_code">i</pre> by <pre class="inline_code">steps[i]</pre> elements forward except for the last (steps should have 1
 dimension less then <pre class="inline_code">a</pre> and <pre class="inline_code">kernel</pre>), just like it would be by <pre class="inline_code">fconvolve</pre>
 with the difference, that everything is accumulated for the kernel instead of
 the original node.<div style="display:block; height: 0.5em"></div>
 The last dimension of <pre class="inline_code">a</pre> and <pre class="inline_code">kernel</pre> should be equal, therefor it has no
 step in that dimension since the complete kernel is multiplied in that
 dimension.
</div></div><div style="display: block; height: 2em;"></div>

    </div>
</center>
  <div id="footer">
    <center>
    <div class="content">
      <div class="row">
        <div class="column">
           David Schwarzbeck, 2022</br>
          Licensed under the <a href="https://github.com/Frobeniusnorm/Flint/blob/main/LICENCE">Apache License</a>, Version 2.0
        </div>
        <div class="column">&nbsp;</div>
        <div class="column">&nbsp;</div>
        <div class="column">
          <a href="https://github.com/Frobeniusnorm/Flint/">Github</a>
        </div>
      </div>
    </div>
    <i style="color: #D0D0D0;">This site values your privacy, does not use cookies, javascript or other malware and does not sell anything.</i></center>
    </center>
  </div>
</body>
</html>

