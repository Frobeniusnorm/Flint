<!DOCTYPE html>
<html>
<head>
  <title>
    Flint Documentation
  </title>
  <link rel="stylesheet" href="style.css" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
</head>

<body>

  <div id="header-bar">
    <div class="left-spaced">
      <img src="flint.png" style="width:5.2em; height:3em; display: inline-block; vertical-align: middle;" />
      <a class="item" href="index.html">About</a>
      <a class="item selected"  href="documentation.html">Documentation</a>
      <a class="item">Tutorial</a>
    </div>
  </div>
  <div id="showcase_background" style="min-height: 18em; background: linear-gradient(90deg, rgba(2,0,36,1) 0%, rgba(153,213,23,1) 0%, rgba(0,179,255,1) 100%);">
    <center style="margin-top:2em">
      <h1>
        Documentation <u>flint.h</u>
      </h1>
    </center>
  </div>
  <center>
    <div class="content" style="margin-top: -3.1em">
        <div class="card">    <span class="card_header">Overview</span></div><br /><div class="card"><span class="card_header" style="font-size:1.2em">Types</span><ul><li><a href="#FLogType_">enum FLogType </a></li><li><a href="#FType_">enum FType </a></li><li><a href="#FOperation_">struct FOperation </a></li><li><a href="#FResultData_">struct FResultData </a></li><li><a href="#FGraphNode_">struct FGraphNode </a></li><li><a href="#FStore_">struct FStore </a></li></ul><span class="card_header" style="font-size:1.2em">Functions</span><ul><li><a href="#flintInit">void flintInit(int backends)</a></li><li><a href="#flintInit_cpu">void flintInit_cpu()</a></li><li><a href="#flintInit_gpu">void flintInit_gpu()</a></li><li><a href="#flintCleanup">void flintCleanup()</a></li><li><a href="#flintCleanup_cpu">void flintCleanup_cpu()</a></li><li><a href="#flintCleanup_gpu">void flintCleanup_gpu()</a></li><li><a href="#fSetLoggingLevel">void fSetLoggingLevel(int)</a></li><li><a href="#flogging">void flogging(FLogType type, const char *msg)</a></li><li><a href="#enable_eager_execution">void enable_eager_execution()</a></li><li><a href="#disable_eager_execution">void disable_eager_execution()</a></li><li><a href="#is_eager_execution">int is_eager_execution()</a></li><li><a href="#fCreateGraph">FGraphNode *fCreateGraph(const void *data, const int num_entries,
                         const FType data_type, const size_t *shape,
                         const int dimensions)</a></li><li><a href="#fconstant_i">FGraphNode *fconstant_i(const int value, const size_t *shape,
                        const int dimensions)</a></li><li><a href="#fconstant_l">FGraphNode *fconstant_l(const long value, const size_t *shape,
                        const int dimensions)</a></li><li><a href="#fconstant_f">FGraphNode *fconstant_f(const float value, const size_t *shape,
                        const int dimensions)</a></li><li><a href="#fconstant_d">FGraphNode *fconstant_d(const double value, const size_t *shape,
                        const int dimensions)</a></li><li><a href="#fFreeGraph">void fFreeGraph(FGraphNode *graph)</a></li><li><a href="#fCopyGraph">FGraphNode *fCopyGraph(const FGraphNode *graph)</a></li><li><a href="#fExecuteGraph">FGraphNode *fExecuteGraph(FGraphNode *node)</a></li><li><a href="#fExecuteGraph_cpu">FGraphNode *fExecuteGraph_cpu(FGraphNode *node)</a></li><li><a href="#fExecuteGraph_gpu">FGraphNode *fExecuteGraph_gpu(FGraphNode *node)</a></li><li><a href="#fExecuteGraph_cpu_eagerly">FGraphNode *fExecuteGraph_cpu_eagerly(FGraphNode *node)</a></li><li><a href="#fExecuteGraph_gpu_eagerly">FGraphNode *fExecuteGraph_gpu_eagerly(FGraphNode *node)</a></li><li><a href="#fCalculateGradient">FGraphNode *fCalculateGradient(FGraphNode *outputfct, const FGraphNode *dx)</a></li><li><a href="#fadd_g">FGraphNode *fadd_g(FGraphNode *a, FGraphNode *b)</a></li><li><a href="#fsub_g">FGraphNode *fsub_g(FGraphNode *a, FGraphNode *b)</a></li><li><a href="#fdiv_g">FGraphNode *fdiv_g(FGraphNode *a, FGraphNode *b)</a></li><li><a href="#fmul_g">FGraphNode *fmul_g(FGraphNode *a, FGraphNode *b)</a></li><li><a href="#fpow_g">FGraphNode *fpow_g(FGraphNode *a, FGraphNode *b)</a></li><li><a href="#fadd_ci">FGraphNode *fadd_ci(FGraphNode *a, const int b)</a></li><li><a href="#fadd_cl">FGraphNode *fadd_cl(FGraphNode *a, const long b)</a></li><li><a href="#fadd_cf">FGraphNode *fadd_cf(FGraphNode *a, const float b)</a></li><li><a href="#fadd_cd">FGraphNode *fadd_cd(FGraphNode *a, const double b)</a></li><li><a href="#fsub_ci">FGraphNode *fsub_ci(FGraphNode *a, const int b)</a></li><li><a href="#fsub_cl">FGraphNode *fsub_cl(FGraphNode *a, const long b)</a></li><li><a href="#fsub_cf">FGraphNode *fsub_cf(FGraphNode *a, const float b)</a></li><li><a href="#fsub_cd">FGraphNode *fsub_cd(FGraphNode *a, const double b)</a></li><li><a href="#fsub_ici">FGraphNode *fsub_ici(const int a, FGraphNode *b)</a></li><li><a href="#fsub_icl">FGraphNode *fsub_icl(const long a, FGraphNode *b)</a></li><li><a href="#fsub_icf">FGraphNode *fsub_icf(const float a, FGraphNode *b)</a></li><li><a href="#fsub_icd">FGraphNode *fsub_icd(const double a, FGraphNode *b)</a></li><li><a href="#fdiv_ci">FGraphNode *fdiv_ci(FGraphNode *a, const int b)</a></li><li><a href="#fdiv_cl">FGraphNode *fdiv_cl(FGraphNode *a, const long b)</a></li><li><a href="#fdiv_cf">FGraphNode *fdiv_cf(FGraphNode *a, const float b)</a></li><li><a href="#fdiv_cd">FGraphNode *fdiv_cd(FGraphNode *a, const double b)</a></li><li><a href="#fdiv_ici">FGraphNode *fdiv_ici(const int a, FGraphNode *b)</a></li><li><a href="#fdiv_icl">FGraphNode *fdiv_icl(const long a, FGraphNode *b)</a></li><li><a href="#fdiv_icf">FGraphNode *fdiv_icf(const float a, FGraphNode *b)</a></li><li><a href="#fdiv_icd">FGraphNode *fdiv_icd(const double a, FGraphNode *b)</a></li><li><a href="#fmul_ci">FGraphNode *fmul_ci(FGraphNode *a, const int b)</a></li><li><a href="#fmul_cl">FGraphNode *fmul_cl(FGraphNode *a, const long b)</a></li><li><a href="#fmul_cf">FGraphNode *fmul_cf(FGraphNode *a, const float b)</a></li><li><a href="#fmul_cd">FGraphNode *fmul_cd(FGraphNode *a, const double b)</a></li><li><a href="#fpow_ci">FGraphNode *fpow_ci(FGraphNode *a, const int b)</a></li><li><a href="#fpow_cl">FGraphNode *fpow_cl(FGraphNode *a, const long b)</a></li><li><a href="#fpow_cf">FGraphNode *fpow_cf(FGraphNode *a, const float b)</a></li><li><a href="#fpow_cd">FGraphNode *fpow_cd(FGraphNode *a, const double b)</a></li><li><a href="#flog">FGraphNode *flog(FGraphNode *a)</a></li><li><a href="#flog2">FGraphNode *flog2(FGraphNode *a)</a></li><li><a href="#flog10">FGraphNode *flog10(FGraphNode *a)</a></li><li><a href="#fsin">FGraphNode *fsin(FGraphNode *a)</a></li><li><a href="#fsqrt_g">FGraphNode *fsqrt_g(FGraphNode *a)</a></li><li><a href="#fcos">FGraphNode *fcos(FGraphNode *a)</a></li><li><a href="#ftan">FGraphNode *ftan(FGraphNode *a)</a></li><li><a href="#fasin">FGraphNode *fasin(FGraphNode *a)</a></li><li><a href="#facos">FGraphNode *facos(FGraphNode *a)</a></li><li><a href="#fatan">FGraphNode *fatan(FGraphNode *a)</a></li><li><a href="#fneg">FGraphNode *fneg(FGraphNode *a)</a></li><li><a href="#fsign">FGraphNode *fsign(FGraphNode *a)</a></li><li><a href="#feven">FGraphNode *feven(FGraphNode *a)</a></li><li><a href="#fless_g">FGraphNode *fless_g(FGraphNode *a, FGraphNode *b)</a></li><li><a href="#fgreater_g">FGraphNode *fgreater_g(FGraphNode *a, FGraphNode *b)</a></li><li><a href="#fequal_g">FGraphNode *fequal_g(FGraphNode *a, FGraphNode *b)</a></li><li><a href="#fless_ci">FGraphNode *fless_ci(FGraphNode *a, const int b)</a></li><li><a href="#fless_cl">FGraphNode *fless_cl(FGraphNode *a, const long b)</a></li><li><a href="#fless_cf">FGraphNode *fless_cf(FGraphNode *a, const float b)</a></li><li><a href="#fless_cd">FGraphNode *fless_cd(FGraphNode *a, const double b)</a></li><li><a href="#fgreater_ci">FGraphNode *fgreater_ci(FGraphNode *a, const int b)</a></li><li><a href="#fgreater_cl">FGraphNode *fgreater_cl(FGraphNode *a, const long b)</a></li><li><a href="#fgreater_cf">FGraphNode *fgreater_cf(FGraphNode *a, const float b)</a></li><li><a href="#fgreater_cd">FGraphNode *fgreater_cd(FGraphNode *a, const double b)</a></li><li><a href="#fequal_ci">FGraphNode *fequal_ci(FGraphNode *a, const int b)</a></li><li><a href="#fequal_cl">FGraphNode *fequal_cl(FGraphNode *a, const long b)</a></li><li><a href="#fequal_cf">FGraphNode *fequal_cf(FGraphNode *a, const float b)</a></li><li><a href="#fequal_cd">FGraphNode *fequal_cd(FGraphNode *a, const double b)</a></li><li><a href="#fmatmul">FGraphNode *fmatmul(FGraphNode *a, FGraphNode *b)</a></li><li><a href="#fflatten">FGraphNode *fflatten(FGraphNode *a)</a></li><li><a href="#fflatten_dimension">FGraphNode *fflatten_dimension(FGraphNode *a, int dimension)</a></li><li><a href="#fconvert">FGraphNode *fconvert(FGraphNode *a, FType newtype)</a></li><li><a href="#freshape">FGraphNode *freshape(FGraphNode *a, size_t *newshape, int dimensions)</a></li><li><a href="#fmin_g">FGraphNode *fmin_g(FGraphNode *a, FGraphNode *b)</a></li><li><a href="#fmin_ci">FGraphNode *fmin_ci(FGraphNode *a, const int b)</a></li><li><a href="#fmin_cl">FGraphNode *fmin_cl(FGraphNode *a, const long b)</a></li><li><a href="#fmin_cf">FGraphNode *fmin_cf(FGraphNode *a, const float b)</a></li><li><a href="#fmin_cd">FGraphNode *fmin_cd(FGraphNode *a, const double b)</a></li><li><a href="#fmax_g">FGraphNode *fmax_g(FGraphNode *a, FGraphNode *b)</a></li><li><a href="#fmax_ci">FGraphNode *fmax_ci(FGraphNode *a, const int b)</a></li><li><a href="#fmax_cl">FGraphNode *fmax_cl(FGraphNode *a, const long b)</a></li><li><a href="#fmax_cf">FGraphNode *fmax_cf(FGraphNode *a, const float b)</a></li><li><a href="#fmax_cd">FGraphNode *fmax_cd(FGraphNode *a, const double b)</a></li><li><a href="#freduce_sum">FGraphNode *freduce_sum(FGraphNode *a,
                        const int dimension)</a></li><li><a href="#freduce_mul">FGraphNode *freduce_mul(FGraphNode *a, const int dimension)</a></li><li><a href="#fslice">FGraphNode *fslice(FGraphNode *a, const long *start, const long *end)</a></li><li><a href="#fslice_step">FGraphNode *fslice_step(FGraphNode *a, const long *start, const long *end,
                        const long *step)</a></li><li><a href="#fextend">FGraphNode *fextend(FGraphNode *a, const size_t *new_shape,
                    const size_t *insert_at)</a></li><li><a href="#fextend_step">FGraphNode *fextend_step(FGraphNode *a, const size_t *new_shape,
                         const size_t *insert_at, const long *step_size)</a></li><li><a href="#fabs_g">FGraphNode *fabs_g(FGraphNode *a)</a></li><li><a href="#frepeat">FGraphNode *frepeat(FGraphNode *a, int *repititions)</a></li><li><a href="#ftranspose">FGraphNode *ftranspose(FGraphNode *a, int *transpositions)</a></li><li><a href="#fconvolve">FGraphNode *fconvolve(FGraphNode *a, FGraphNode *kernel, unsigned int *steps)</a></li></ul></div>
        <div style="display: block; height: 2em;"></div>
        <div id="flintInit"></div><div class="card"><pre class="card_header_code">void flintInit(int backends)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Initializes the cpu and the gpu backends. These functions are already
 implicitly called by the execution functions if necessary. The method allows
 disabling of the gpu backend (by passing <pre class="inline_code">FLINT_BACKEND_ONLY_CPU</pre>), disabling
 of the cpu backend (by passing <pre class="inline_code">FLINT_BACKEND_BOTH</pre>), initializing both
 backends explicitly (by passing <pre class="inline_code">FLINT_BACKEND_BOTH</pre>, which is recommended,
 since Flint is then allowed to choose the framework with heuristics). Only
 use those functions if you...<ul><li>...want to explicitly decide where and when the initialization should take
      place
</li><li>...want to only start one backend</li></ul> </div></div><div style="display: block; height: 2em;"></div>
<div id="flintInit_cpu"></div><div class="card"><pre class="card_header_code">void flintInit_cpu()</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Don't call this function explicitly if you intent to use Flint normally. Use
  <a href="#flintInit"><pre class="inline_code">flintInit</pre></a> </div></div><div style="display: block; height: 2em;"></div>
<div id="flintInit_gpu"></div><div class="card"><pre class="card_header_code">void flintInit_gpu()</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Don't call this function explicitly if you intent to use Flint normally. Use
  <a href="#flintInit"><pre class="inline_code">flintInit</pre></a> </div></div><div style="display: block; height: 2em;"></div>
<div id="flintCleanup"></div><div class="card"><pre class="card_header_code">void flintCleanup()</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Deallocates any resourced allocated by the corresponding backends.
This method calls the other two (following) which are only executed if the
framework was initialized, else they do nothing. </div></div><div style="display: block; height: 2em;"></div>
<div id="flintCleanup_cpu"></div><div class="card"><pre class="card_header_code">void flintCleanup_cpu()</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Deallocates any resourced allocated by the cpu backend, if it was
 initialized, else it does nothing. </div></div><div style="display: block; height: 2em;"></div>
<div id="flintCleanup_gpu"></div><div class="card"><pre class="card_header_code">void flintCleanup_gpu()</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Deallocates any resourced allocated by the gpu backend, if it was
 initialized, else it does nothing. </div></div><div style="display: block; height: 2em;"></div>
<div id="fSetLoggingLevel"></div><div class="card"><pre class="card_header_code">void fSetLoggingLevel(int)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Sets the logging level of the framework. Adjust this for debugging purposes,
 or if you release software in which Flint is contained.
 See also:  <a href="#flogging"><pre class="inline_code">flogging</pre></a>, <pre class="inline_code">FLogType</pre><div style="display:block; height: 0.5em"></div>
 Levels:<ul><li>0: No logging
</li><li>1: Only <pre class="inline_code">F_ERROR</pre>
</li><li>2: Logging level 1 + <pre class="inline_code">F_WARNING</pre> (should be used for production)
</li><li>3: Logging level 2 + <pre class="inline_code">F_INFO</pre> (for developement)
</li><li>4: Logging level 3 + <pre class="inline_code">F_VERBOSE</pre> (for library developement)
</li><li>5: Logging level 4 + <pre class="inline_code">F_DEBUG</pre> (when a bug in the library has been found)</li></ul>
</div></div><div style="display: block; height: 2em;"></div>
<div id="FLogType_"></div><div class="card"><pre class="card_header_code">enum FLogType </pre></div>
<br />
<div class="card"><div style="padding: 5px;">
 See also:  <a href="#flogging"><pre class="inline_code">flogging</pre></a>, <pre class="inline_code">FLogType</pre><ul><li><pre class="inline_code">F_DEBUG</pre> (only internal debugging informations of the framework),
</li><li><pre class="inline_code">F_VERBOSE</pre> (verbose information, may be helpful to users of the
    library),
</li><li><pre class="inline_code">F_INFO</pre> (informational data of the framework, e.g. which
    graphics card has been chosen),
</li><li><pre class="inline_code">F_ERROR</pre> (unrecoverable errors,
    generated by function calls to the framework, raises a exception
    everytime),
</li><li><pre class="inline_code">F_WARNING</pre> (probably unwanted behaviour or undefined behaviour caused
    by missuse of functions).</li></ul>
</div></div><div style="display: block; height: 2em;"></div>
<div id="flogging"></div><div class="card"><pre class="card_header_code">void flogging(FLogType type, const char *msg)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Logs a NULL terminated string with the given logging level.
 See also:  <a href="#fSetLoggingLevel"><pre class="inline_code">fSetLoggingLevel</pre></a> </div></div><div style="display: block; height: 2em;"></div>
<div id="enable_eager_execution"></div><div class="card"><pre class="card_header_code">void enable_eager_execution()</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> All graph nodes that represent actual operations are after this call
 executed eagerly, i.e. they are executed during graph construction. </div></div><div style="display: block; height: 2em;"></div>
<div id="disable_eager_execution"></div><div class="card"><pre class="card_header_code">void disable_eager_execution()</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Disable eager execution, i.e. the graph is constructed without execution of
 the nodes until a operation makes the execution of a parent graph necessary
 or the user calls  <a href="#fExecuteGraph"><pre class="inline_code">fExecuteGraph</pre></a>. </div></div><div style="display: block; height: 2em;"></div>
<div id="is_eager_execution"></div><div class="card"><pre class="card_header_code">int is_eager_execution()</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Returns 1 if eager execution has been enabled, else 0 </div></div><div style="display: block; height: 2em;"></div>
<div id="FType_"></div><div class="card"><pre class="card_header_code">enum FType </pre></div>
<br />
<div class="card"><div style="padding: 5px;"> The 4 allowed data types:<ul><li><pre class="inline_code">F_INT32</pre>(integer, 32bit)
</li><li><pre class="inline_code">F_INT64</pre>(integer, 64bit)
</li><li><pre class="inline_code">F_FLOAT32</pre> (floating point, 32bit)
</li><li><pre class="inline_code">F_FLOAT64</pre> (floating point, 64bit)</li></ul>
</div></div><div style="display: block; height: 2em;"></div>
<div id="FOperation_"></div><div class="card"><pre class="card_header_code">struct FOperation </pre></div>
<br />
<div class="card"><div style="padding: 5px;">
 Describes one operation. An operation always has a shape, described by
 <pre class="inline_code">FOperation.shape</pre> which is an array of size
 <pre class="inline_code">FOperation.dimensions</pre> with each entry denoting the size of the
 corresponding dimension. <pre class="inline_code">FOperation.op_type</pre> denotes the type of
 operation, <pre class="inline_code">FOperation.data_type</pre> the type of the underlying data,
 <pre class="inline_code">FOperation.additional_data</pre> is operation specific.</div></div><div style="display: block; height: 2em;"></div>
<div id="FResultData_"></div><div class="card"><pre class="card_header_code">struct FResultData </pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Stores the resulting data after an execution of  <a href="#fExecuteGraph"><pre class="inline_code">fExecuteGraph</pre></a> (or implicit
 execution). The data can be found in <pre class="inline_code">FResultData.data</pre>, the datatype in
 <pre class="inline_code">FOperation.data_type</pre> of the corresponding <pre class="inline_code">FGraphNode</pre>.
 The number of entries (not number of bytes) is stored in
 <pre class="inline_code">FResultData.num_entries</pre>. The data may be consistently modified
 if...<ul><li>...the data size is changed, num_entries is equivalently updated and
      <pre class="inline_code">realloc</pre> is used and ...
</li><li>...the data was not already loaded to the gpu (i.e. the result must be the
        return value of  <a href="#fExecuteGraph_cpu"><pre class="inline_code">fExecuteGraph_cpu</pre></a>)</li></ul>
</div></div><div style="display: block; height: 2em;"></div>
<div id="FGraphNode_"></div><div class="card"><pre class="card_header_code">struct FGraphNode </pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Describes one node in the Graph. Stores the corresponding operation in
 <pre class="inline_code">FGraphNode.operation</pre>, an array of predecessors (the arguments of
 the operation) in <pre class="inline_code">FGraphNode.predecessors</pre>, its size in
 <pre class="inline_code">FGraphNode.num_predecessor</pre> and the reference counter in
 <pre class="inline_code">FGraphNode.reference_counter</pre>. Do not modify any parameter by yourself,
 since the framework manages them, but you can read the data and structure
 from them. The nodes are allocated by the operation functions, they and their
 members should neither be manually created, edited or freed except by the
 corresponding flint methods. </div></div><div style="display: block; height: 2em;"></div>
<div id="FStore_"></div><div class="card"><pre class="card_header_code">struct FStore </pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Result of an call to  <a href="#fCreateGraph"><pre class="inline_code">fCreateGraph</pre></a>, see <pre class="inline_code">FResultData</pre>.
 Data of this Operation may not be changed manually when using a GPU Backend.
</div></div><div style="display: block; height: 2em;"></div>
<div id="fCreateGraph"></div><div class="card"><pre class="card_header_code">FGraphNode *fCreateGraph(const void *data, const int num_entries,
                         const FType data_type, const size_t *shape,
                         const int dimensions)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"><ul><li><pre class="inline_code">data</pre>: pointer to the flattened data array that should be loaded into
   the node
</li><li><pre class="inline_code">num_entries</pre>: the number of elements (NOT BYTES!) that should
   be loaded
</li><li><pre class="inline_code">data_type</pre>: the datatype of <pre class="inline_code">data</pre>
</li><li><pre class="inline_code">shape</pre>: an array of size <pre class="inline_code">dimensions</pre>, each entry describing the
   size of the corresponding dimension. Make sure, <pre class="inline_code">data</pre> is at least as
   large as the product of all entries in <pre class="inline_code">shape</pre>
</li><li><pre class="inline_code">dimensions</pre>: the number of dimensions
</li></ul>
 Creates a Graph with a single store instruction, the data is
 copied to intern memory, so after return of the function, <pre class="inline_code">data</pre> and <pre class="inline_code">shape</pre>
 may be deleted. </div></div><div style="display: block; height: 2em;"></div>
<div id="fconstant_i"></div><div class="card"><pre class="card_header_code">FGraphNode *fconstant_i(const int value, const size_t *shape,
                        const int dimensions)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Creates a tensor that contains the single given values in all entries<div style="display:block; height: 0.5em"></div><ul><li><pre class="inline_code">value</pre>: the value this tensor should consist of
</li><li><pre class="inline_code">shape</pre>: an array of size <pre class="inline_code">dimensions</pre>, each entry describing the size
    of the corresponding dimension.
</li><li><pre class="inline_code">dimensions</pre>: the number of dimensions</li></ul>
</div></div><div style="display: block; height: 2em;"></div>
<div id="fconstant_l"></div><div class="card"><pre class="card_header_code">FGraphNode *fconstant_l(const long value, const size_t *shape,
                        const int dimensions)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Creates a tensor that contains the single given values in all entries<div style="display:block; height: 0.5em"></div><ul><li><pre class="inline_code">value</pre>: the value this tensor should consist of
</li><li><pre class="inline_code">shape</pre>: an array of size <pre class="inline_code">dimensions</pre>, each entry describing the size
    of the corresponding dimension.
</li><li><pre class="inline_code">dimensions</pre>: the number of dimensions</li></ul>
</div></div><div style="display: block; height: 2em;"></div>
<div id="fconstant_f"></div><div class="card"><pre class="card_header_code">FGraphNode *fconstant_f(const float value, const size_t *shape,
                        const int dimensions)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Creates a tensor that contains the single given values in all entries<div style="display:block; height: 0.5em"></div><ul><li><pre class="inline_code">value</pre>: the value this tensor should consist of
</li><li><pre class="inline_code">shape</pre>: an array of size <pre class="inline_code">dimensions</pre>, each entry describing the size
    of the corresponding dimension.
</li><li><pre class="inline_code">dimensions</pre>: the number of dimensions</li></ul>
</div></div><div style="display: block; height: 2em;"></div>
<div id="fconstant_d"></div><div class="card"><pre class="card_header_code">FGraphNode *fconstant_d(const double value, const size_t *shape,
                        const int dimensions)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Creates a tensor that contains the single given values in all entries<div style="display:block; height: 0.5em"></div><ul><li><pre class="inline_code">value</pre>: the value this tensor should consist of
</li><li><pre class="inline_code">shape</pre>: an array of size <pre class="inline_code">dimensions</pre>, each entry describing the size
    of the corresponding dimension.
</li><li><pre class="inline_code">dimensions</pre>: the number of dimensions</li></ul>
</div></div><div style="display: block; height: 2em;"></div>
<div id="fFreeGraph"></div><div class="card"><pre class="card_header_code">void fFreeGraph(FGraphNode *graph)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Decrements <pre class="inline_code">FGraphNode.reference_counter</pre> of <pre class="inline_code">graph</pre> (for reference
 counting) and deallocates the node and its corresponding data, if the counter
 becomes 0. If the node is deallocated, the same process is repeated with its
 predecessors. So you can safely connect nodes multiple times and have only to
 free the leaf nodes (i.e. the results), without caring about cross-reference,
 since those are handled by the reference counting system.</div></div><div style="display: block; height: 2em;"></div>
<div id="fCopyGraph"></div><div class="card"><pre class="card_header_code">FGraphNode *fCopyGraph(const FGraphNode *graph)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Copies the graph node, the corresponding operation and additional data and
 the predecessors (their <pre class="inline_code">FGraphNode.reference_counter</pre> is
 incremented) </div></div><div style="display: block; height: 2em;"></div>
<div id="fExecuteGraph"></div><div class="card"><pre class="card_header_code">FGraphNode *fExecuteGraph(FGraphNode *node)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Executes the graph node operations from all yet to be executed predecessors
 to <pre class="inline_code">node</pre> and returns a node with a <pre class="inline_code">FResultData</pre> operation in
 which the resulting data is stored. If the graph is executed by the GPU
 backend, a opencl kernel containing all selected operations (the nodes
 operation and those indirect parent operations which were not yet
 executed) are compiled and executed. The kernels are cashed, so it improves
 the performance of a program if the same graph-structures are reused (not
 necessary the same nodes, but the same combination of nodes), since then the
 backend can reuse already compiled kernels. If the CPU backend is chosen, it
 does not matter, since every operation is executed independently.</div></div><div style="display: block; height: 2em;"></div>
<div id="fExecuteGraph_cpu"></div><div class="card"><pre class="card_header_code">FGraphNode *fExecuteGraph_cpu(FGraphNode *node)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Executes the graph node operations from all yet to be executed predecessors
 to <pre class="inline_code">node</pre> and returns a node with a <pre class="inline_code">FResultData</pre> operation in
 which the resulting data is stored. </div></div><div style="display: block; height: 2em;"></div>
<div id="fExecuteGraph_gpu"></div><div class="card"><pre class="card_header_code">FGraphNode *fExecuteGraph_gpu(FGraphNode *node)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Executes the graph node operations from all yet to be executed predecessors
 to <pre class="inline_code">node</pre> and returns a node with a <pre class="inline_code">FResultData</pre> operation in
 which the resulting data is stored. For the GPU
 backend, a opencl kernel containing all selected operations (the nodes
 operation and those indirect parent operations which were not yet executed)
 are compiled and executed. The kernels are cashed, so it improves the
 performance of a program if the same graph-structures are reused (not
 necessary the same nodes, but the same combination of nodes), since then the
 backend can reuse already compiled kernels. </div></div><div style="display: block; height: 2em;"></div>
<div id="fExecuteGraph_cpu_eagerly"></div><div class="card"><pre class="card_header_code">FGraphNode *fExecuteGraph_cpu_eagerly(FGraphNode *node)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Executes the graph node operations from all yet to be executed predecessors
 to <pre class="inline_code">node</pre> and returns a node with a <pre class="inline_code">FResultData</pre> operation in
 which the resulting data is stored. </div></div><div style="display: block; height: 2em;"></div>
<div id="fExecuteGraph_gpu_eagerly"></div><div class="card"><pre class="card_header_code">FGraphNode *fExecuteGraph_gpu_eagerly(FGraphNode *node)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Executes the graph node operations from all yet to be executed predecessors
 to <pre class="inline_code">node</pre> and returns a node with a <pre class="inline_code">FResultData</pre> operation in
 which the resulting data is stored. For the GPU
 backend, a opencl kernel containing all selected operations (the nodes
 operation and those indirect parent operations which were not yet executed)
 are compiled and executed. The kernels are cashed, so it improves the
 performance of a program if the same graph-structures are reused (not
 necessary the same nodes, but the same combination of nodes), since then the
 backend can reuse already compiled kernels. </div></div><div style="display: block; height: 2em;"></div>
<div id="fCalculateGradient"></div><div class="card"><pre class="card_header_code">FGraphNode *fCalculateGradient(FGraphNode *outputfct, const FGraphNode *dx)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Calculates the overall gradient of an output node to a variable.<div style="display:block; height: 0.5em"></div><ul><li><pre class="inline_code">outputfct</pre>: the Node which represents the chain of functions of which
    the gradient is to be computed.
</li><li><pre class="inline_code">dx</pre>: the variable for which outputfct is derived for</li></ul>
</div></div><div style="display: block; height: 2em;"></div>
<div id="fadd_g"></div><div class="card"><pre class="card_header_code">FGraphNode *fadd_g(FGraphNode *a, FGraphNode *b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Elementwise addition of <pre class="inline_code">a</pre> and <pre class="inline_code">b</pre>, i.e. <pre class="inline_code">a[i] + b[i]</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div id="fsub_g"></div><div class="card"><pre class="card_header_code">FGraphNode *fsub_g(FGraphNode *a, FGraphNode *b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Elementwise substraction of <pre class="inline_code">a</pre> and <pre class="inline_code">b</pre>, i.e. <pre class="inline_code">a[i] - b[i]</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div id="fdiv_g"></div><div class="card"><pre class="card_header_code">FGraphNode *fdiv_g(FGraphNode *a, FGraphNode *b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Elementwise division of <pre class="inline_code">a</pre> and <pre class="inline_code">b</pre>, i.e. <pre class="inline_code">a[i] / b[i]</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div id="fmul_g"></div><div class="card"><pre class="card_header_code">FGraphNode *fmul_g(FGraphNode *a, FGraphNode *b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Elementwise multiplication of <pre class="inline_code">a</pre> and <pre class="inline_code">b</pre>, i.e. <pre class="inline_code">a[i] * b[i]</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div id="fpow_g"></div><div class="card"><pre class="card_header_code">FGraphNode *fpow_g(FGraphNode *a, FGraphNode *b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Elementwise power of <pre class="inline_code">a</pre> and <pre class="inline_code">b</pre>, i.e. <pre class="inline_code">pow(a[i], b[i])</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div id="fadd_ci"></div><div class="card"><pre class="card_header_code">FGraphNode *fadd_ci(FGraphNode *a, const int b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Elementwise addition of a and b, i.e. <pre class="inline_code">a[i] + b</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div id="fadd_cl"></div><div class="card"><pre class="card_header_code">FGraphNode *fadd_cl(FGraphNode *a, const long b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Elementwise addition of a and b, i.e. <pre class="inline_code">a[i] + b</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div id="fadd_cf"></div><div class="card"><pre class="card_header_code">FGraphNode *fadd_cf(FGraphNode *a, const float b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Elementwise addition of a and b, i.e. <pre class="inline_code">a[i] + b</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div id="fadd_cd"></div><div class="card"><pre class="card_header_code">FGraphNode *fadd_cd(FGraphNode *a, const double b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Elementwise addition of a and b, i.e. <pre class="inline_code">a[i] + b</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div id="fsub_ci"></div><div class="card"><pre class="card_header_code">FGraphNode *fsub_ci(FGraphNode *a, const int b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Elementwise subtraction of a and b, i.e. <pre class="inline_code">a[i] - b</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div id="fsub_cl"></div><div class="card"><pre class="card_header_code">FGraphNode *fsub_cl(FGraphNode *a, const long b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Elementwise subtraction of a and b, i.e. <pre class="inline_code">a[i] - b</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div id="fsub_cf"></div><div class="card"><pre class="card_header_code">FGraphNode *fsub_cf(FGraphNode *a, const float b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Elementwise subtraction of a and b, i.e. <pre class="inline_code">a[i] - b</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div id="fsub_cd"></div><div class="card"><pre class="card_header_code">FGraphNode *fsub_cd(FGraphNode *a, const double b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Elementwise subtraction of a and b, i.e. <pre class="inline_code">a[i] - b</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div id="fsub_ici"></div><div class="card"><pre class="card_header_code">FGraphNode *fsub_ici(const int a, FGraphNode *b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Elementwise subtraction of a and b, i.e. <pre class="inline_code">a - b[i]</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div id="fsub_icl"></div><div class="card"><pre class="card_header_code">FGraphNode *fsub_icl(const long a, FGraphNode *b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Elementwise subtraction of a and b, i.e. <pre class="inline_code">a - b[i]</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div id="fsub_icf"></div><div class="card"><pre class="card_header_code">FGraphNode *fsub_icf(const float a, FGraphNode *b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Elementwise subtraction of a and b, i.e. <pre class="inline_code">a - b[i]</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div id="fsub_icd"></div><div class="card"><pre class="card_header_code">FGraphNode *fsub_icd(const double a, FGraphNode *b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Elementwise subtraction of a and b, i.e. <pre class="inline_code">a - b[i]</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div id="fdiv_ci"></div><div class="card"><pre class="card_header_code">FGraphNode *fdiv_ci(FGraphNode *a, const int b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Elementwise division of a and b, i.e. <pre class="inline_code">a[i] / b</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div id="fdiv_cl"></div><div class="card"><pre class="card_header_code">FGraphNode *fdiv_cl(FGraphNode *a, const long b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Elementwise division of a and b, i.e. <pre class="inline_code">a[i] / b</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div id="fdiv_cf"></div><div class="card"><pre class="card_header_code">FGraphNode *fdiv_cf(FGraphNode *a, const float b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Elementwise division of a and b, i.e. <pre class="inline_code">a[i] / b</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div id="fdiv_cd"></div><div class="card"><pre class="card_header_code">FGraphNode *fdiv_cd(FGraphNode *a, const double b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Elementwise division of a and b, i.e. <pre class="inline_code">a[i] / b</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div id="fdiv_ici"></div><div class="card"><pre class="card_header_code">FGraphNode *fdiv_ici(const int a, FGraphNode *b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Elementwise division of a and b, i.e. <pre class="inline_code">a / b[i]</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div id="fdiv_icl"></div><div class="card"><pre class="card_header_code">FGraphNode *fdiv_icl(const long a, FGraphNode *b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Elementwise division of a and b, i.e. <pre class="inline_code">a / b[i]</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div id="fdiv_icf"></div><div class="card"><pre class="card_header_code">FGraphNode *fdiv_icf(const float a, FGraphNode *b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Elementwise division of a and b, i.e. <pre class="inline_code">a / b[i]</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div id="fdiv_icd"></div><div class="card"><pre class="card_header_code">FGraphNode *fdiv_icd(const double a, FGraphNode *b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Elementwise division of a and b, i.e. <pre class="inline_code">a / b[i]</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div id="fmul_ci"></div><div class="card"><pre class="card_header_code">FGraphNode *fmul_ci(FGraphNode *a, const int b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Elementwise multiplication of a and b, i.e. <pre class="inline_code">a[i] * b</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div id="fmul_cl"></div><div class="card"><pre class="card_header_code">FGraphNode *fmul_cl(FGraphNode *a, const long b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Elementwise multiplication of a and b, i.e. <pre class="inline_code">a[i] * b</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div id="fmul_cf"></div><div class="card"><pre class="card_header_code">FGraphNode *fmul_cf(FGraphNode *a, const float b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Elementwise multiplication of a and b, i.e. <pre class="inline_code">a[i] * b</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div id="fmul_cd"></div><div class="card"><pre class="card_header_code">FGraphNode *fmul_cd(FGraphNode *a, const double b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Elementwise multiplication of a and b, i.e. <pre class="inline_code">a[i] * b</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div id="fpow_ci"></div><div class="card"><pre class="card_header_code">FGraphNode *fpow_ci(FGraphNode *a, const int b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Takes the elementwise power of a to b, i.e. <pre class="inline_code">pow(a[i], b)</pre>.</div></div><div style="display: block; height: 2em;"></div>
<div id="fpow_cl"></div><div class="card"><pre class="card_header_code">FGraphNode *fpow_cl(FGraphNode *a, const long b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Takes the elementwise power of a to b, i.e. <pre class="inline_code">pow(a[i], b)</pre>.</div></div><div style="display: block; height: 2em;"></div>
<div id="fpow_cf"></div><div class="card"><pre class="card_header_code">FGraphNode *fpow_cf(FGraphNode *a, const float b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Takes the elementwise power of a to b, i.e. <pre class="inline_code">pow(a[i], b)</pre>.</div></div><div style="display: block; height: 2em;"></div>
<div id="fpow_cd"></div><div class="card"><pre class="card_header_code">FGraphNode *fpow_cd(FGraphNode *a, const double b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Takes the elementwise power of a to b, i.e. <pre class="inline_code">pow(a[i], b)</pre>.</div></div><div style="display: block; height: 2em;"></div>
<div id="flog"></div><div class="card"><pre class="card_header_code">FGraphNode *flog(FGraphNode *a)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Takes the elementwise natural logarithm of <pre class="inline_code">a</pre> </div></div><div style="display: block; height: 2em;"></div>
<div id="flog2"></div><div class="card"><pre class="card_header_code">FGraphNode *flog2(FGraphNode *a)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Takes the elementwise logarithm of <pre class="inline_code">a</pre> to the basis of 2 </div></div><div style="display: block; height: 2em;"></div>
<div id="flog10"></div><div class="card"><pre class="card_header_code">FGraphNode *flog10(FGraphNode *a)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Takes the elementwise logarithm of <pre class="inline_code">a</pre> to the basis of 10 </div></div><div style="display: block; height: 2em;"></div>
<div id="fsin"></div><div class="card"><pre class="card_header_code">FGraphNode *fsin(FGraphNode *a)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Takes the elementwise sinus of a </div></div><div style="display: block; height: 2em;"></div>
<div id="fsqrt_g"></div><div class="card"><pre class="card_header_code">FGraphNode *fsqrt_g(FGraphNode *a)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Takes the elementwise square root of a </div></div><div style="display: block; height: 2em;"></div>
<div id="fcos"></div><div class="card"><pre class="card_header_code">FGraphNode *fcos(FGraphNode *a)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Takes the elementwise cosinus of a </div></div><div style="display: block; height: 2em;"></div>
<div id="ftan"></div><div class="card"><pre class="card_header_code">FGraphNode *ftan(FGraphNode *a)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Takes the elementwise tangents of a </div></div><div style="display: block; height: 2em;"></div>
<div id="fasin"></div><div class="card"><pre class="card_header_code">FGraphNode *fasin(FGraphNode *a)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Takes the elementwise inverse sinus of a </div></div><div style="display: block; height: 2em;"></div>
<div id="facos"></div><div class="card"><pre class="card_header_code">FGraphNode *facos(FGraphNode *a)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Takes the elementwise inverse cosinus of a </div></div><div style="display: block; height: 2em;"></div>
<div id="fatan"></div><div class="card"><pre class="card_header_code">FGraphNode *fatan(FGraphNode *a)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Takes the elementwise inverse tangents of a </div></div><div style="display: block; height: 2em;"></div>
<div id="fneg"></div><div class="card"><pre class="card_header_code">FGraphNode *fneg(FGraphNode *a)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Negates the elements of <pre class="inline_code">a</pre>, i.e. <pre class="inline_code">-a[i]</pre> </div></div><div style="display: block; height: 2em;"></div>
<div id="fsign"></div><div class="card"><pre class="card_header_code">FGraphNode *fsign(FGraphNode *a)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Returns a tensor x with the shape of a with <pre class="inline_code">x[i] = 1</pre> if <pre class="inline_code">a[i] &gt;= 0</pre> else
 <pre class="inline_code">x[i] = -1</pre> </div></div><div style="display: block; height: 2em;"></div>
<div id="feven"></div><div class="card"><pre class="card_header_code">FGraphNode *feven(FGraphNode *a)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Returns a tensor <pre class="inline_code">x</pre> with the shape of <pre class="inline_code">a</pre> with <pre class="inline_code">x[i] = 1</pre> if <pre class="inline_code">a[i] % 2 =
 0</pre> else <pre class="inline_code">x[i] = 0</pre> </div></div><div style="display: block; height: 2em;"></div>
<div id="fless_g"></div><div class="card"><pre class="card_header_code">FGraphNode *fless_g(FGraphNode *a, FGraphNode *b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Compares two tensors elementwise by <pre class="inline_code">a &lt; b</pre> and returns a 0,1 INT32 Tensor
</div></div><div style="display: block; height: 2em;"></div>
<div id="fgreater_g"></div><div class="card"><pre class="card_header_code">FGraphNode *fgreater_g(FGraphNode *a, FGraphNode *b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Compares two tensors elementwise by <pre class="inline_code">a &gt; b</pre> and returns a 0,1 INT32 Tensor
</div></div><div style="display: block; height: 2em;"></div>
<div id="fequal_g"></div><div class="card"><pre class="card_header_code">FGraphNode *fequal_g(FGraphNode *a, FGraphNode *b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Compares two tensors elementwise by <pre class="inline_code">a = b</pre><pre class="inline_code"> and returns a 0,1 INT32 Tensor
</pre></div></div><div style="display: block; height: 2em;"></div>
<div id="fless_ci"></div><div class="card"><pre class="card_header_code">FGraphNode *fless_ci(FGraphNode *a, const int b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Compares a tensor and a constant elementwise by <pre class="inline_code">a &lt; b</pre> and returns a 0,1
 <pre class="inline_code">INT32</pre> Tensor. See  <a href="#fless_g"><pre class="inline_code">fless_g</pre></a>. </div></div><div style="display: block; height: 2em;"></div>
<div id="fless_cl"></div><div class="card"><pre class="card_header_code">FGraphNode *fless_cl(FGraphNode *a, const long b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Compares a tensor and a constant elementwise by <pre class="inline_code">a &lt; b</pre> and returns a 0,1
 <pre class="inline_code">INT32</pre> Tensor. See  <a href="#fless_g"><pre class="inline_code">fless_g</pre></a>. </div></div><div style="display: block; height: 2em;"></div>
<div id="fless_cf"></div><div class="card"><pre class="card_header_code">FGraphNode *fless_cf(FGraphNode *a, const float b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Compares a tensor and a constant elementwise by <pre class="inline_code">a &lt; b</pre> and returns a 0,1
 <pre class="inline_code">INT32</pre> Tensor. See  <a href="#fless_g"><pre class="inline_code">fless_g</pre></a>. </div></div><div style="display: block; height: 2em;"></div>
<div id="fless_cd"></div><div class="card"><pre class="card_header_code">FGraphNode *fless_cd(FGraphNode *a, const double b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Compares a tensor and a constant elementwise by <pre class="inline_code">a &lt; b</pre> and returns a 0,1
 <pre class="inline_code">INT32</pre> Tensor. See  <a href="#fless_g"><pre class="inline_code">fless_g</pre></a>. </div></div><div style="display: block; height: 2em;"></div>
<div id="fgreater_ci"></div><div class="card"><pre class="card_header_code">FGraphNode *fgreater_ci(FGraphNode *a, const int b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Compares a tensor and a constant elementwise by <pre class="inline_code">a &gt; b</pre> and returns a 0,1
 <pre class="inline_code">INT32</pre> Tensor. See  <a href="#fgreater_g"><pre class="inline_code">fgreater_g</pre></a>. </div></div><div style="display: block; height: 2em;"></div>
<div id="fgreater_cl"></div><div class="card"><pre class="card_header_code">FGraphNode *fgreater_cl(FGraphNode *a, const long b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Compares a tensor and a constant elementwise by <pre class="inline_code">a &gt; b</pre> and returns a 0,1
 <pre class="inline_code">INT32</pre> Tensor. See  <a href="#fgreater_g"><pre class="inline_code">fgreater_g</pre></a>. </div></div><div style="display: block; height: 2em;"></div>
<div id="fgreater_cf"></div><div class="card"><pre class="card_header_code">FGraphNode *fgreater_cf(FGraphNode *a, const float b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Compares a tensor and a constant elementwise by <pre class="inline_code">a &gt; b</pre> and returns a 0,1
 <pre class="inline_code">INT32</pre> Tensor. See  <a href="#fgreater_g"><pre class="inline_code">fgreater_g</pre></a>. </div></div><div style="display: block; height: 2em;"></div>
<div id="fgreater_cd"></div><div class="card"><pre class="card_header_code">FGraphNode *fgreater_cd(FGraphNode *a, const double b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Compares a tensor and a constant elementwise by <pre class="inline_code">a &gt; b</pre> and returns a 0,1
 <pre class="inline_code">INT32</pre> Tensor. See  <a href="#fgreater_g"><pre class="inline_code">fgreater_g</pre></a>. </div></div><div style="display: block; height: 2em;"></div>
<div id="fequal_ci"></div><div class="card"><pre class="card_header_code">FGraphNode *fequal_ci(FGraphNode *a, const int b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Compares a tensor and a constant elementwise by <pre class="inline_code">a = b</pre> and returns a 0,1
 <pre class="inline_code">INT32</pre> Tensor. See  <a href="#fequal_g"><pre class="inline_code">fequal_g</pre></a>. </div></div><div style="display: block; height: 2em;"></div>
<div id="fequal_cl"></div><div class="card"><pre class="card_header_code">FGraphNode *fequal_cl(FGraphNode *a, const long b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Compares a tensor and a constant elementwise by <pre class="inline_code">a = b</pre> and returns a 0,1
 <pre class="inline_code">INT32</pre> Tensor. See  <a href="#fequal_g"><pre class="inline_code">fequal_g</pre></a>. </div></div><div style="display: block; height: 2em;"></div>
<div id="fequal_cf"></div><div class="card"><pre class="card_header_code">FGraphNode *fequal_cf(FGraphNode *a, const float b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Compares a tensor and a constant elementwise by <pre class="inline_code">a = b</pre> and returns a 0,1
 <pre class="inline_code">INT32</pre> Tensor. See  <a href="#fequal_g"><pre class="inline_code">fequal_g</pre></a>. </div></div><div style="display: block; height: 2em;"></div>
<div id="fequal_cd"></div><div class="card"><pre class="card_header_code">FGraphNode *fequal_cd(FGraphNode *a, const double b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Compares a tensor and a constant elementwise by <pre class="inline_code">a = b</pre> and returns a 0,1
 <pre class="inline_code">INT32</pre> Tensor. See  <a href="#fequal_g"><pre class="inline_code">fequal_g</pre></a>. </div></div><div style="display: block; height: 2em;"></div>
<div id="fmatmul"></div><div class="card"><pre class="card_header_code">FGraphNode *fmatmul(FGraphNode *a, FGraphNode *b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Carries out matrix multiplication on the last two dimensions of the tensors.<div style="display:block; height: 0.5em"></div>
 E.g. a matrix multiplication of two tensors with shapes <pre class="inline_code">(64, 32, 16)</pre> and
 <pre class="inline_code">(16, 24)</pre> will yield a tensor with shape <pre class="inline_code">(64, 32, 24)</pre>.<div style="display:block; height: 0.5em"></div>
 Since for one entry of the
 tensor multiple other previous entries are needed, the operand tensors need
 to be executed first. Therefor the method will implicitly (or eagerly)
 execute the two parameter nodes <pre class="inline_code">a</pre> and <pre class="inline_code">b</pre> if their data is not allready
 present, the given pointers will be overwritten with the results. </div></div><div style="display: block; height: 2em;"></div>
<div id="fflatten"></div><div class="card"><pre class="card_header_code">FGraphNode *fflatten(FGraphNode *a)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Flattens the complete tensor to a tensor with one
dimension.
E.g.<pre class="inline_code">flattened([[[3, 1, 4], [2, 1, 5]], [[0, 4, 2], [4, 7, 9]]]) = [3, 1, 4, 2,
1, 5, 0, 4, 2, 4, 7, 9]</pre>.
</div></div><div style="display: block; height: 2em;"></div>
<div id="fflatten_dimension"></div><div class="card"><pre class="card_header_code">FGraphNode *fflatten_dimension(FGraphNode *a, int dimension)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Flattens a tensor <pre class="inline_code">a</pre> with <pre class="inline_code">n</pre> dimensions along
<pre class="inline_code">dimension</pre>, resulting in a tensor with <pre class="inline_code">n-1</pre> dimensions.
Flattening a dimension will remove it from the shape of the tensor, therefor its
not possible to flatten the dimension 0.
A Tensor <pre class="inline_code">[[[3, 1, 4], [2, 1, 5]], [[0, 4, 2], [4, 7, 9]]]</pre> flattened
along dimension 1 will result in <pre class="inline_code">[[3,1,4], [2,1,5], [0,4,2], [4,7,9]]</pre>.
</div></div><div style="display: block; height: 2em;"></div>
<div id="fconvert"></div><div class="card"><pre class="card_header_code">FGraphNode *fconvert(FGraphNode *a, FType newtype)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Converts the data of <pre class="inline_code">a</pre> to the type given by <pre class="inline_code">newtype</pre></div></div><div style="display: block; height: 2em;"></div>
<div id="freshape"></div><div class="card"><pre class="card_header_code">FGraphNode *freshape(FGraphNode *a, size_t *newshape, int dimensions)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Reshapes the underlying data of the tensor to the new shape. The product of
each dimension of the new shape must be the same as the product of the
dimensions of the previous shape (i.e. it must describe the same number of
entries of the tensor).</div></div><div style="display: block; height: 2em;"></div>
<div id="fmin_g"></div><div class="card"><pre class="card_header_code">FGraphNode *fmin_g(FGraphNode *a, FGraphNode *b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Takes the minimum of two tensors element wise along the last dimension of
 each, i.e. <pre class="inline_code">a[i]</pre> if <pre class="inline_code">a[i] &lt; b[i]</pre> else <pre class="inline_code">b[i]</pre> </div></div><div style="display: block; height: 2em;"></div>
<div id="fmin_ci"></div><div class="card"><pre class="card_header_code">FGraphNode *fmin_ci(FGraphNode *a, const int b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Takes the minimum of two tensors element wise along the last dimension of
 each, i.e. <pre class="inline_code">a[i]</pre> if <pre class="inline_code">a[i] &lt; b</pre> else <pre class="inline_code">b</pre> </div></div><div style="display: block; height: 2em;"></div>
<div id="fmin_cl"></div><div class="card"><pre class="card_header_code">FGraphNode *fmin_cl(FGraphNode *a, const long b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Takes the minimum of two tensors element wise along the last dimension of
 each, i.e. <pre class="inline_code">a[i]</pre> if <pre class="inline_code">a[i] &lt; b</pre> else <pre class="inline_code">b</pre> </div></div><div style="display: block; height: 2em;"></div>
<div id="fmin_cf"></div><div class="card"><pre class="card_header_code">FGraphNode *fmin_cf(FGraphNode *a, const float b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Takes the minimum of two tensors element wise along the last dimension of
 each, i.e. <pre class="inline_code">a[i]</pre> if <pre class="inline_code">a[i] &lt; b</pre> else <pre class="inline_code">b</pre> </div></div><div style="display: block; height: 2em;"></div>
<div id="fmin_cd"></div><div class="card"><pre class="card_header_code">FGraphNode *fmin_cd(FGraphNode *a, const double b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Takes the minimum of two tensors element wise along the last dimension of
 each, i.e. <pre class="inline_code">a[i]</pre> if <pre class="inline_code">a[i] &lt; b</pre> else <pre class="inline_code">b</pre> </div></div><div style="display: block; height: 2em;"></div>
<div id="fmax_g"></div><div class="card"><pre class="card_header_code">FGraphNode *fmax_g(FGraphNode *a, FGraphNode *b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Takes the maximum of two tensors element wise along the last dimension of
 each, i.e. <pre class="inline_code">a[i]</pre> if <pre class="inline_code">a[i] &gt; b[i]</pre> else <pre class="inline_code">b[i]</pre> </div></div><div style="display: block; height: 2em;"></div>
<div id="fmax_ci"></div><div class="card"><pre class="card_header_code">FGraphNode *fmax_ci(FGraphNode *a, const int b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Takes the maximum of two tensors element wise along the last dimension of
 each, i.e. <pre class="inline_code">a[i]</pre> if <pre class="inline_code">a[i] &gt; b</pre> else <pre class="inline_code">b</pre> </div></div><div style="display: block; height: 2em;"></div>
<div id="fmax_cl"></div><div class="card"><pre class="card_header_code">FGraphNode *fmax_cl(FGraphNode *a, const long b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Takes the maximum of two tensors element wise along the last dimension of
 each, i.e. <pre class="inline_code">a[i]</pre> if <pre class="inline_code">a[i] &gt; b</pre> else <pre class="inline_code">b</pre> </div></div><div style="display: block; height: 2em;"></div>
<div id="fmax_cf"></div><div class="card"><pre class="card_header_code">FGraphNode *fmax_cf(FGraphNode *a, const float b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Takes the maximum of two tensors element wise along the last dimension of
 each, i.e. <pre class="inline_code">a[i]</pre> if <pre class="inline_code">a[i] &gt; b</pre> else <pre class="inline_code">b</pre> </div></div><div style="display: block; height: 2em;"></div>
<div id="fmax_cd"></div><div class="card"><pre class="card_header_code">FGraphNode *fmax_cd(FGraphNode *a, const double b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Takes the maximum of two tensors element wise along the last dimension of
 each, i.e. <pre class="inline_code">a[i]</pre> if <pre class="inline_code">a[i] &gt; b</pre> else <pre class="inline_code">b</pre> </div></div><div style="display: block; height: 2em;"></div>
<div id="freduce_sum"></div><div class="card"><pre class="card_header_code">FGraphNode *freduce_sum(FGraphNode *a,
                        const int dimension)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Reduces one dimension of the tensor by additive folding e.g.<div style="display:block; height: 0.5em"></div>
 <pre class="inline_code">freduce_sum([[1,2,3], [4,5,6]], 0) = [5,7,9]</pre>,
 <pre class="inline_code">freduce_sum([[1,2,3], [4,5,6]], 1) = [6,15]</pre><div style="display:block; height: 0.5em"></div>
 The results of the predecessor node must be available, to
 ensure that the method may execute the parameter node. The corresponding
 result is then stored in the memory pointed to by <pre class="inline_code">a</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div id="freduce_mul"></div><div class="card"><pre class="card_header_code">FGraphNode *freduce_mul(FGraphNode *a, const int dimension)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Reduces one dimension of the tensor by multiplicative folding e.g.<div style="display:block; height: 0.5em"></div>
 <pre class="inline_code">freduce_mul([[1,2,3], [4,5,6]], 0) = [4,10,18]</pre>,
 <pre class="inline_code">freduce_mul([[1,2,3], [4,5,6]], 1) = [6, 120]</pre><div style="display:block; height: 0.5em"></div>
 The results of the predecessor node must be available; to
 ensure that the method may execute the parameter node. The corresponding
 result is then stored in the memory pointed to by a. </div></div><div style="display: block; height: 2em;"></div>
<div id="fslice"></div><div class="card"><pre class="card_header_code">FGraphNode *fslice(FGraphNode *a, const long *start, const long *end)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Selects a slice of the tensor with a dimension wise start and end index.
 <pre class="inline_code">start</pre> and <pre class="inline_code">end</pre> are arrays with as many entries
 as the tensor has dimensions. They may contain negative values,
 which are then subtracted from the end of the tensor (e.g. <pre class="inline_code">-1</pre> means the
 last element). <pre class="inline_code">start</pre> is inclusive and describes the start index of the
 selection per dimension and <pre class="inline_code">end</pre> describes the end index per dimension
 and is exclusive.
</div></div><div style="display: block; height: 2em;"></div>
<div id="fslice_step"></div><div class="card"><pre class="card_header_code">FGraphNode *fslice_step(FGraphNode *a, const long *start, const long *end,
                        const long *step)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Selects a slice of the tensor with a dimension wise start index, end index
 and step size. <pre class="inline_code">start</pre>, <pre class="inline_code">end</pre> and <pre class="inline_code">step</pre> are arrays with as
 many entries as the tensor has dimensions. <pre class="inline_code">start</pre> and <pre class="inline_code">end</pre> may
 contain negative values, which are then subtracted from the end of the tensor
 (e.g. <pre class="inline_code">-1</pre> means the last element). <pre class="inline_code">start</pre> is inclusive and describes the
 start index of the selection per dimension and <pre class="inline_code">end</pre> describes the end
 index per dimension and is exclusive. <pre class="inline_code">step</pre> contains the per
 dimension step size (e.g. <pre class="inline_code">2</pre> meaning every second element will be selected
 etc.) and may be negative as well, which reverses the traversal order (the
 first elements are selected as the last ones). For a negative step size,
 <pre class="inline_code">start &gt; end</pre> must hold (for a positive of course <pre class="inline_code">end &gt;
 start</pre>) for each dimension.
</div></div><div style="display: block; height: 2em;"></div>
<div id="fextend"></div><div class="card"><pre class="card_header_code">FGraphNode *fextend(FGraphNode *a, const size_t *new_shape,
                    const size_t *insert_at)</pre></div>
<br />
<div class="card"><div style="padding: 5px;">
 Creates a new tensor of zeroes with the requested shape. The original tensor
 is embedded at the given indices.<ul><li><pre class="inline_code">a</pre> original tensor which shape is to be extended
</li><li><pre class="inline_code">new_shape</pre> array of new sizes per dimension. Has <pre class="inline_code">dimension</pre> number of
    entries
</li><li><pre class="inline_code">insert_at</pre> array with indices per dimension denoting where <pre class="inline_code">a</pre> is to be
    placed in the resulting tensor</li></ul>
</div></div><div style="display: block; height: 2em;"></div>
<div id="fextend_step"></div><div class="card"><pre class="card_header_code">FGraphNode *fextend_step(FGraphNode *a, const size_t *new_shape,
                         const size_t *insert_at, const long *step_size)</pre></div>
<br />
<div class="card"><div style="padding: 5px;">
 Creates a new tensor of zeroes with the requested shape. The original tensor
 is embedded at the given indices.<ul><li><pre class="inline_code">a</pre> original tensor which shape is to be extended,
</li><li><pre class="inline_code">new_shape</pre> array of new sizes per dimension. Has <pre class="inline_code">dimension</pre> number of
    entries.
</li><li><pre class="inline_code">insert_at</pre> array with indices per dimension denoting where <pre class="inline_code">a</pre> is to be
    placed in the resulting tensor. Has a value per dimension.
</li><li><pre class="inline_code">step_size</pre> allows to pull apart <pre class="inline_code">a</pre>, emplacing <pre class="inline_code">step_size[i]</pre> 0 between
    each value of <pre class="inline_code">a</pre>. Has a value per dimension.</li></ul>
</div></div><div style="display: block; height: 2em;"></div>
<div id="fabs_g"></div><div class="card"><pre class="card_header_code">FGraphNode *fabs_g(FGraphNode *a)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Takes the elementwise absolute value of <pre class="inline_code">a</pre>, i.e. <pre class="inline_code">|a[i]|</pre> </div></div><div style="display: block; height: 2em;"></div>
<div id="frepeat"></div><div class="card"><pre class="card_header_code">FGraphNode *frepeat(FGraphNode *a, int *repititions)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Repeats dimensions of a tensor multiple times<div style="display:block; height: 0.5em"></div><ul><li><pre class="inline_code">a</pre>: the node in which dimensions are to be repeated
</li><li><pre class="inline_code">repititions</pre>: array with the same number of entries as the tensor has
    dimensions
</li></ul> e.g. <pre class="inline_code">repeat([[0,1], [2,3]], [2, 3]) = [[0,1,0,1,0,1],
 [2,3,2,3,2,3], [0,1,0,1,0,1], [2,3,2,3,2,3]]</pre>
</div></div><div style="display: block; height: 2em;"></div>
<div id="ftranspose"></div><div class="card"><pre class="card_header_code">FGraphNode *ftranspose(FGraphNode *a, int *transpositions)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Transposes this tensor along multiple dimensions<div style="display:block; height: 0.5em"></div><ul><li><pre class="inline_code">a</pre>: the node which should be transposed
</li><li><pre class="inline_code">transpositions</pre>: an array with the same number of entries as the tensor
   has dimensions, which gives the perumtation of dimensions.
</li></ul> The tensor will have a resulting shape in which the size in dimension <pre class="inline_code">i</pre>
 corresponds to the former size in dimension <pre class="inline_code">transpositions[i]</pre>.
</div></div><div style="display: block; height: 2em;"></div>
<div id="fconvolve"></div><div class="card"><pre class="card_header_code">FGraphNode *fconvolve(FGraphNode *a, FGraphNode *kernel, unsigned int *steps)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Convolves the <pre class="inline_code">n</pre>-dimensional input tensor <pre class="inline_code">a</pre> with a <pre class="inline_code">n</pre>-dimensional filter
 kernel <pre class="inline_code">kernel</pre> and a per dimensional step size <pre class="inline_code">steps</pre> with size of <pre class="inline_code">n-1</pre>.
 It is expected that <pre class="inline_code">a</pre> and <pre class="inline_code">kernel</pre> have the same size in their last
 dimension (which will be completly reduced by the convolution). In all other
 dimensions the size of <pre class="inline_code">a</pre> should be larger or equal to the size of <pre class="inline_code">kernel</pre>.
 The <pre class="inline_code">kernel</pre> will be 'slid' over <pre class="inline_code">a</pre> in each dimension, multiplying all
 values of <pre class="inline_code">kernel</pre> with the corresponding ones in <pre class="inline_code">a</pre> and moving the kernel
 further by the value given in <pre class="inline_code">steps</pre> in that corresponding dimension. The
 implementation does not care about padding (if <pre class="inline_code">a</pre> is in a dimension not
 divisable by the step size, the remainder is truncated). If you want to
 include it use  <a href="#fextend"><pre class="inline_code">fextend</pre></a> or similar.<div style="display:block; height: 0.5em"></div>
 The resulting Tensor will therefor have a shape with dimensionality <pre class="inline_code">n - 1</pre>
 and size of <pre class="inline_code">resulting_shape[i] = a-&gt;operation-&gt;shape[i] / steps[i]</pre>
</div></div><div style="display: block; height: 2em;"></div>

    </div>
</center>
  <div id="footer">
    <center>
    <div class="content">
      <div class="row">
        <div class="column">
           David Schwarzbeck, 2022</br>
          Licensed under the <a href="https://github.com/Frobeniusnorm/Flint/blob/main/LICENCE">Apache License</a>, Version 2.0
        </div>
        <div class="column">&nbsp;</div>
        <div class="column">&nbsp;</div>
        <div class="column">
          <a href="https://github.com/Frobeniusnorm/Flint/">Github</a>
        </div>
      </div>
    </div>
    </center>
  </div>
</body>
</html>
