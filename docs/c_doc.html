<!DOCTYPE html>
<html>
<head>
  <title>
    Flint Documentation
  </title>
  <link rel="stylesheet" href="style.css" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
</head>

<body>

  <div id="header-bar">
    <div class="left-spaced">
      <img src="flint.png" style="width:5.5em; height:2.9em; display: inline-block; vertical-align: middle;" />
      <a class="item" href="index.html">About</a>
      <span class="item selected">Documentation</span>
      <a class="item">Tutorial</a>
    </div>
  </div>
  <center>
    <div class="content">
        <div style="display: block; height: 5em;"></div>
        <div class="card">
            <span class="card_header">Overview</span>
        </div>
        <br />
        <div class="card">
            Some Stuff
        </div>
        <div style="display: block; height: 2em;"></div>
        <div class="card"><pre class="card_header_code">
void flintInit(int cpu, int gpu)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Initializes the cpu and the gpu backend. These functions are already
 implicitly called by the execution functions if necessary. The method allows
 disabling of the gpu backend (by passing 0 to its gpu parameter), the cpu
 backend cannot be disabled (if a 0 is passed to the cpu backend in the first
 method, it may still be started by <pre class="inline_code">fExecuteGraph</pre>, if it decides that the
 cpu backend should be chosen). Only use those functions if you...<ul><li>...want to explicitly decide where and when the initialization should take
      place
</li><li>...want to only start one backend</li></ul> </div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
void flintInit_cpu()</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Initializes the cpu backend. These functions are already implicitly called
 by the execution functions if necessary. Only use those functions if you...<ul><li>...want to explicitly decide where and when the initialization should take
      place
</li><li>...want to only start one backend</li></ul> </div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
void flintInit_gpu()</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Initializes the gpu backend. These functions are already implicitly called
 by the execution functions if necessary. Only use those functions if you...<ul><li>...want to explicitly decide where and when the initialization should take
      place
</li><li>...want to only start one backend</li></ul> </div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
void flintCleanup()</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Deallocates any resourced allocated by the corresponding backends.
This method calls the other two (following) which are only executed if the
framework was initialized, else they do nothing. </div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
void flintCleanup_cpu()</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Deallocates any resourced allocated by the cpu backend, if it was
 initialized, else it does nothing. </div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
void flintCleanup_gpu()</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Deallocates any resourced allocated by the gpu backend, if it was
 initialized, else it does nothing. </div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
void fSetLoggingLevel(int)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Sets the logging level of the framework. Adjust this for debugging purposes,
 or if you release software in which Flint is contained.
 See also: <pre class="inline_code">flog</pre>, <pre class="inline_code">FLogType</pre>

 Levels:<ul><li>0: No logging
</li><li>1: Only <pre class="inline_code">F_ERROR</pre>
</li><li>2: Logging level 1 + <pre class="inline_code">F_WARNING</pre> (should be used for production)
</li><li>3: Logging level 2 + <pre class="inline_code">F_INFO</pre> (for developement)
</li><li>4: Logging level 3 + <pre class="inline_code">F_VERBOSE</pre> (for library developement)
</li><li>5: Logging level 4 + <pre class="inline_code">F_DEBUG</pre> (when a bug in the library has been found)
</li></ul> test </div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
enum FLogType </pre></div>
<br />
<div class="card"><div style="padding: 5px;">
 See also: <pre class="inline_code">flog</pre>, <pre class="inline_code">FLogType</pre><ul><li><pre class="inline_code">F_DEBUG</pre> (only internal debugging informations of the framework),
</li><li><pre class="inline_code">F_VERBOSE</pre> (verbose information, may be helpful to users of the
    library),
</li><li><pre class="inline_code">F_INFO</pre> (informational data of the framework, e.g. which
    graphics card has been chosen),
</li><li><pre class="inline_code">F_ERROR</pre> (unrecoverable errors,
    generated by function calls to the framework, raises a exception
    everytime),
</li><li><pre class="inline_code">F_WARNING</pre> (probably unwanted behaviour or undefined behaviour caused
    by missuse of functions).</li></ul>
</div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
void flogging(FLogType type, const char *msg)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Logs a NULL terminated string with the given logging level.
 See also: <pre class="inline_code">fSetLoggingLevel</pre> </div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
void enable_eager_execution()</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> All graph nodes that represent actual operations are after this call
 executed eagerly, i.e. they are executed during graph construction. </div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
void disable_eager_execution()</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Disable eager execution, i.e. the graph is constructed without execution of
 the nodes until a operation makes the execution of a parent graph necessary
 or the user calls <pre class="inline_code">fExecuteGraph</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
int is_eager_execution()</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Returns 1 if eager execution has been enabled, else 0 </div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
enum FType </pre></div>
<br />
<div class="card"><div style="padding: 5px;"> The 4 allowed data types:<ul><li><pre class="inline_code">F_INT32</pre>(integer, 32bit)
</li><li><pre class="inline_code">F_INT64</pre>(integer, 64bit)
</li><li><pre class="inline_code">F_FLOAT32</pre> (floating point, 32bit)
</li><li><pre class="inline_code">F_FLOAT64</pre> (floating point, 64bit)</li></ul>
</div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
struct FOperation </pre></div>
<br />
<div class="card"><div style="padding: 5px;">
 Describes one operation. An operation always has a shape, described by
 <pre class="inline_code">FOperation.shape</pre> which is an array of size
 <pre class="inline_code">FOperation.dimensions</pre> with each entry denoting the size of the
 corresponding dimension. <pre class="inline_code">FOperation.op_type</pre> denotes the type of
 operation, <pre class="inline_code">FOperation.data_type</pre> the type of the underlying data,
 <pre class="inline_code">FOperation.additional_data</pre> is operation specific.</div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
struct FResultData </pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Stores the resulting data after an execution of <pre class="inline_code">fExecuteGraph</pre> (or implicit
 execution). The data can be found in <pre class="inline_code">FResultData.data</pre>, the datatype in
 <pre class="inline_code">FOperation.data_type</pre> of the corresponding <pre class="inline_code">FGraphNode</pre>.
 The number of entries (not number of bytes) is stored in
 <pre class="inline_code">FResultData.num_entries</pre>. The data may be consistently modified
 if...<ul><li>...the data size is changed, num_entries is equivalently updated and
      <pre class="inline_code">realloc</pre> is used and ...
</li><li>...the data was not already loaded to the gpu (i.e. the result must be the
        return value of <pre class="inline_code">fExecuteGraph_cpu</pre>)</li></ul>
</div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
struct FGraphNode </pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Describes one node in the Graph. Stores the corresponding operation in
 <pre class="inline_code">FGraphNode.operation</pre>, an array of predecessors (the arguments of
 the operation) in <pre class="inline_code">FGraphNode.predecessors</pre>, its size in
 <pre class="inline_code">FGraphNode.num_predecessor</pre> and the reference counter in
 <pre class="inline_code">FGraphNode.reference_counter</pre>. Do not modify any parameter by yourself,
 since the framework manages them, but you can read the data and structure
 from them. The nodes are allocated by the operation functions, they and their
 members should neither be manually created, edited or freed except by the
 corresponding flint methods. </div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
struct FStore </pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Result of an call to <pre class="inline_code">fCreateGraph</pre>, see <pre class="inline_code">FResultData</pre>.
 Data of this Operation may always be changed, since the framework assumes
 this. </div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
FGraphNode *fCreateGraph(const void *data, const int num_entries,
                         const FType data_type, const size_t *shape,
                         const int dimensions)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"><ul><li><pre class="inline_code">data</pre>: pointer to the flattened data array that should be loaded into
   the node
</li><li><pre class="inline_code">num_entries</pre>: the number of elements (NOT BYTES!) that should
   be loaded
</li><li><pre class="inline_code">data_type</pre>: the datatype of <pre class="inline_code">data</pre>
</li><li><pre class="inline_code">shape</pre>: an array of size <pre class="inline_code">dimensions</pre>, each entry describing the
   size of the corresponding dimension. Make sure, <pre class="inline_code">data</pre> is at least as
   large as the product of all entries in <pre class="inline_code">shape</pre>
</li><li><pre class="inline_code">dimensions</pre>: the number of dimensions
</li></ul>
 Creates a Graph with a single store instruction, the data is
 copied to intern memory, so after return of the function, <pre class="inline_code">data</pre> and <pre class="inline_code">shape</pre>
 may be deleted. </div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
FGraphNode *fconstant_i(const int value, const size_t *shape,
                        const int dimensions)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Creates a tensor that contains the single given values in all entries
<ul><li><pre class="inline_code">value</pre>: the value this tensor should consist of
</li><li><pre class="inline_code">shape</pre>: an array of size <pre class="inline_code">dimensions</pre>, each entry describing the size
    of the corresponding dimension.
</li><li><pre class="inline_code">dimensions</pre>: the number of dimensions</li></ul>
</div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
FGraphNode *fconstant_l(const long value, const size_t *shape,
                        const int dimensions)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Creates a tensor that contains the single given values in all entries
<ul><li><pre class="inline_code">value</pre>: the value this tensor should consist of
</li><li><pre class="inline_code">shape</pre>: an array of size <pre class="inline_code">dimensions</pre>, each entry describing the size
    of the corresponding dimension.
</li><li><pre class="inline_code">dimensions</pre>: the number of dimensions</li></ul>
</div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
FGraphNode *fconstant_f(const float value, const size_t *shape,
                        const int dimensions)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Creates a tensor that contains the single given values in all entries
<ul><li><pre class="inline_code">value</pre>: the value this tensor should consist of
</li><li><pre class="inline_code">shape</pre>: an array of size <pre class="inline_code">dimensions</pre>, each entry describing the size
    of the corresponding dimension.
</li><li><pre class="inline_code">dimensions</pre>: the number of dimensions</li></ul>
</div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
FGraphNode *fconstant_d(const double value, const size_t *shape,
                        const int dimensions)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Creates a tensor that contains the single given values in all entries
<ul><li><pre class="inline_code">value</pre>: the value this tensor should consist of
</li><li><pre class="inline_code">shape</pre>: an array of size <pre class="inline_code">dimensions</pre>, each entry describing the size
    of the corresponding dimension.
</li><li><pre class="inline_code">dimensions</pre>: the number of dimensions</li></ul>
</div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
void fFreeGraph(FGraphNode *graph)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Decrements <pre class="inline_code">FGraphNode.reference_counter</pre> of <pre class="inline_code">graph</pre> (for reference
 counting) and deallocates the node and its corresponding data, if the counter
 becomes 0. If the node is deallocated, the same process is repeated with its
 predecessors. So you can safely connect nodes multiple times and have only to
 free the leaf nodes (i.e. the results), without caring about cross-reference,
 since those are handled by the reference counting system.</div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
FGraphNode *fCopyGraph(const FGraphNode *graph)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Copies the graph node, the corresponding operation and additional data and
 the predecessors (their <pre class="inline_code">FGraphNode.reference_counter</pre> is
 incremented) </div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
FGraphNode *fExecuteGraph(FGraphNode *node)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Executes the graph node operations from all yet to be executed predecessors
 to <pre class="inline_code">node</pre> and returns a node with a <pre class="inline_code">FResultData</pre> operation in
 which the resulting data is stored. If the graph is executed by the GPU
 backend, a opencl kernel containing all selected operations (the nodes
 operation and those indirect parent operations which were not yet
 executed) are compiled and executed. The kernels are cashed, so it improves
 the performance of a program if the same graph-structures are reused (not
 necessary the same nodes, but the same combination of nodes), since then the
 backend can reuse already compiled kernels. If the CPU backend is chosen, it
 does not matter, since every operation is executed independently.</div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
FGraphNode *fExecuteGraph_cpu(FGraphNode *node)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Executes the graph node operations from all yet to be executed predecessors
 to <pre class="inline_code">node</pre> and returns a node with a <pre class="inline_code">FResultData</pre> operation in
 which the resulting data is stored. </div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
FGraphNode *fExecuteGraph_gpu(FGraphNode *node)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Executes the graph node operations from all yet to be executed predecessors
 to <pre class="inline_code">node</pre> and returns a node with a <pre class="inline_code">FResultData</pre> operation in
 which the resulting data is stored. For the GPU
 backend, a opencl kernel containing all selected operations (the nodes
 operation and those indirect parent operations which were not yet executed)
 are compiled and executed. The kernels are cashed, so it improves the
 performance of a program if the same graph-structures are reused (not
 necessary the same nodes, but the same combination of nodes), since then the
 backend can reuse already compiled kernels. </div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
FGraphNode *fExecuteGraph_cpu_eagerly(FGraphNode *node)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Executes the graph node operations from all yet to be executed predecessors
 to <pre class="inline_code">node</pre> and returns a node with a <pre class="inline_code">FResultData</pre> operation in
 which the resulting data is stored. </div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
FGraphNode *fExecuteGraph_gpu_eagerly(FGraphNode *node)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Executes the graph node operations from all yet to be executed predecessors
 to <pre class="inline_code">node</pre> and returns a node with a <pre class="inline_code">FResultData</pre> operation in
 which the resulting data is stored. For the GPU
 backend, a opencl kernel containing all selected operations (the nodes
 operation and those indirect parent operations which were not yet executed)
 are compiled and executed. The kernels are cashed, so it improves the
 performance of a program if the same graph-structures are reused (not
 necessary the same nodes, but the same combination of nodes), since then the
 backend can reuse already compiled kernels. </div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
FGraphNode *fCalculateGradient(const FGraphNode *outputfct,
                               const FGraphNode *dx)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Calculates the overall gradient of an output node to a variable.
<ul><li><pre class="inline_code">outputfct</pre>: the Node which represents the chain of functions of which
    the gradient is to be computed.
</li><li><pre class="inline_code">dx</pre>: the variable for which outputfct is derived for</li></ul>
</div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
FGraphNode *fadd_g(FGraphNode *a, FGraphNode *b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Elementwise addition of <pre class="inline_code">a</pre> and <pre class="inline_code">b</pre>, i.e. <pre class="inline_code">a[i] + b[i]</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
FGraphNode *fsub_g(FGraphNode *a, FGraphNode *b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Elementwise substraction of <pre class="inline_code">a</pre> and <pre class="inline_code">b</pre>, i.e. <pre class="inline_code">a[i] - b[i]</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
FGraphNode *fdiv_g(FGraphNode *a, FGraphNode *b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Elementwise division of <pre class="inline_code">a</pre> and <pre class="inline_code">b</pre>, i.e. <pre class="inline_code">a[i] / b[i]</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
FGraphNode *fmul_g(FGraphNode *a, FGraphNode *b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Elementwise multiplication of <pre class="inline_code">a</pre> and <pre class="inline_code">b</pre>, i.e. <pre class="inline_code">a[i] * b[i]</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
FGraphNode *fpow_g(FGraphNode *a, FGraphNode *b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Elementwise power of <pre class="inline_code">a</pre> and <pre class="inline_code">b</pre>, i.e. <pre class="inline_code">pow(a[i], b[i])</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
FGraphNode *fadd_ci(FGraphNode *a, const int b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Elementwise addition of a and b, i.e. <pre class="inline_code">a[i] + b</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
FGraphNode *fadd_cl(FGraphNode *a, const long b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Elementwise addition of a and b, i.e. <pre class="inline_code">a[i] + b</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
FGraphNode *fadd_cf(FGraphNode *a, const float b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Elementwise addition of a and b, i.e. <pre class="inline_code">a[i] + b</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
FGraphNode *fadd_cd(FGraphNode *a, const double b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Elementwise addition of a and b, i.e. <pre class="inline_code">a[i] + b</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
FGraphNode *fsub_ci(FGraphNode *a, const int b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Elementwise subtraction of a and b, i.e. <pre class="inline_code">a[i] - b</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
FGraphNode *fsub_cl(FGraphNode *a, const long b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Elementwise subtraction of a and b, i.e. <pre class="inline_code">a[i] - b</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
FGraphNode *fsub_cf(FGraphNode *a, const float b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Elementwise subtraction of a and b, i.e. <pre class="inline_code">a[i] - b</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
FGraphNode *fsub_cd(FGraphNode *a, const double b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Elementwise subtraction of a and b, i.e. <pre class="inline_code">a[i] - b</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
FGraphNode *fsub_ici(const int a, FGraphNode *b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Elementwise subtraction of a and b, i.e. <pre class="inline_code">a - b[i]</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
FGraphNode *fsub_icl(const long a, FGraphNode *b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Elementwise subtraction of a and b, i.e. <pre class="inline_code">a - b[i]</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
FGraphNode *fsub_icf(const float a, FGraphNode *b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Elementwise subtraction of a and b, i.e. <pre class="inline_code">a - b[i]</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
FGraphNode *fsub_icd(const double a, FGraphNode *b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Elementwise subtraction of a and b, i.e. <pre class="inline_code">a - b[i]</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
FGraphNode *fdiv_ci(FGraphNode *a, const int b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Elementwise division of a and b, i.e. <pre class="inline_code">a[i] / b</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
FGraphNode *fdiv_cl(FGraphNode *a, const long b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Elementwise division of a and b, i.e. <pre class="inline_code">a[i] / b</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
FGraphNode *fdiv_cf(FGraphNode *a, const float b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Elementwise division of a and b, i.e. <pre class="inline_code">a[i] / b</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
FGraphNode *fdiv_cd(FGraphNode *a, const double b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Elementwise division of a and b, i.e. <pre class="inline_code">a[i] / b</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
FGraphNode *fdiv_ici(const int a, FGraphNode *b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Elementwise division of a and b, i.e. <pre class="inline_code">a / b[i]</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
FGraphNode *fdiv_icl(const long a, FGraphNode *b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Elementwise division of a and b, i.e. <pre class="inline_code">a / b[i]</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
FGraphNode *fdiv_icf(const float a, FGraphNode *b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Elementwise division of a and b, i.e. <pre class="inline_code">a / b[i]</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
FGraphNode *fdiv_icd(const double a, FGraphNode *b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Elementwise division of a and b, i.e. <pre class="inline_code">a / b[i]</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
FGraphNode *fmul_ci(FGraphNode *a, const int b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Elementwise multiplication of a and b, i.e. <pre class="inline_code">a[i] * b</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
FGraphNode *fmul_cl(FGraphNode *a, const long b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Elementwise multiplication of a and b, i.e. <pre class="inline_code">a[i] * b</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
FGraphNode *fmul_cf(FGraphNode *a, const float b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Elementwise multiplication of a and b, i.e. <pre class="inline_code">a[i] * b</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
FGraphNode *fmul_cd(FGraphNode *a, const double b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Elementwise multiplication of a and b, i.e. <pre class="inline_code">a[i] * b</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
FGraphNode *fpow_ci(FGraphNode *a, const int b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Takes the elementwise power of a to b, i.e. <pre class="inline_code">pow(a[i], b)</pre>.</div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
FGraphNode *fpow_cl(FGraphNode *a, const long b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Takes the elementwise power of a to b, i.e. <pre class="inline_code">pow(a[i], b)</pre>.</div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
FGraphNode *fpow_cf(FGraphNode *a, const float b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Takes the elementwise power of a to b, i.e. <pre class="inline_code">pow(a[i], b)</pre>.</div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
FGraphNode *fpow_cd(FGraphNode *a, const double b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Takes the elementwise power of a to b, i.e. <pre class="inline_code">pow(a[i], b)</pre>.</div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
FGraphNode *flog(FGraphNode *a)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Takes the elementwise natural logarithm of <pre class="inline_code">a</pre> </div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
FGraphNode *flog2(FGraphNode *a)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Takes the elementwise logarithm of <pre class="inline_code">a</pre> to the basis of 2 </div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
FGraphNode *flog10(FGraphNode *a)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Takes the elementwise logarithm of <pre class="inline_code">a</pre> to the basis of 10 </div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
FGraphNode *fneg(FGraphNode *a)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Negates the elements of <pre class="inline_code">a</pre>, i.e. <pre class="inline_code">-a[i]</pre> </div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
FGraphNode *fsign(FGraphNode *a)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Returns a tensor x with the shape of a with <pre class="inline_code">x[i] = 1</pre> if <pre class="inline_code">a[i] >= 0</pre> else
 <pre class="inline_code">x[i] = -1</pre> </div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
FGraphNode *feven(FGraphNode *a)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Returns a tensor <pre class="inline_code">x</pre> with the shape of <pre class="inline_code">a</pre> with <pre class="inline_code">x[i] = 1</pre> if <pre class="inline_code">a[i] % 2 ==
 0</pre> else <pre class="inline_code">x[i] = 0</pre> </div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
FGraphNode *fless_g(FGraphNode *a, FGraphNode *b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Compares two tensors elementwise by <pre class="inline_code">a < b</pre> and returns a 0,1 INT32 Tensor
</div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
FGraphNode *fgreater_g(FGraphNode *a, FGraphNode *b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Compares two tensors elementwise by <pre class="inline_code">a > b</pre> and returns a 0,1 INT32 Tensor
</div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
FGraphNode *fequal_g(FGraphNode *a, FGraphNode *b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Compares two tensors elementwise by <pre class="inline_code">a = b</pre><pre class="inline_code"> and returns a 0,1 INT32 Tensor
</pre></div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
FGraphNode *fless_ci(FGraphNode *a, const int b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Compares a tensor and a constant elementwise by <pre class="inline_code">a < b</pre> and returns a 0,1
 <pre class="inline_code">INT32</pre> Tensor. See <pre class="inline_code">fless_g</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
FGraphNode *fless_cl(FGraphNode *a, const long b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Compares a tensor and a constant elementwise by <pre class="inline_code">a < b</pre> and returns a 0,1
 <pre class="inline_code">INT32</pre> Tensor. See <pre class="inline_code">fless_g</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
FGraphNode *fless_cf(FGraphNode *a, const float b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Compares a tensor and a constant elementwise by <pre class="inline_code">a < b</pre> and returns a 0,1
 <pre class="inline_code">INT32</pre> Tensor. See <pre class="inline_code">fless_g</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
FGraphNode *fless_cd(FGraphNode *a, const double b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Compares a tensor and a constant elementwise by <pre class="inline_code">a < b</pre> and returns a 0,1
 <pre class="inline_code">INT32</pre> Tensor. See <pre class="inline_code">fless_g</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
FGraphNode *fgreater_ci(FGraphNode *a, const int b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Compares a tensor and a constant elementwise by <pre class="inline_code">a > b</pre> and returns a 0,1
 <pre class="inline_code">INT32</pre> Tensor. See <pre class="inline_code">fgreater_g</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
FGraphNode *fgreater_cl(FGraphNode *a, const long b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Compares a tensor and a constant elementwise by <pre class="inline_code">a > b</pre> and returns a 0,1
 <pre class="inline_code">INT32</pre> Tensor. See <pre class="inline_code">fgreater_g</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
FGraphNode *fgreater_cf(FGraphNode *a, const float b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Compares a tensor and a constant elementwise by <pre class="inline_code">a > b</pre> and returns a 0,1
 <pre class="inline_code">INT32</pre> Tensor. See <pre class="inline_code">fgreater_g</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
FGraphNode *fgreater_cd(FGraphNode *a, const double b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Compares a tensor and a constant elementwise by <pre class="inline_code">a > b</pre> and returns a 0,1
 <pre class="inline_code">INT32</pre> Tensor. See <pre class="inline_code">fgreater_g</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
FGraphNode *fequal_ci(FGraphNode *a, const int b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Compares a tensor and a constant elementwise by <pre class="inline_code">a = b</pre> and returns a 0,1
 <pre class="inline_code">INT32</pre> Tensor. See <pre class="inline_code">fequal_g</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
FGraphNode *fequal_cl(FGraphNode *a, const long b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Compares a tensor and a constant elementwise by <pre class="inline_code">a = b</pre> and returns a 0,1
 <pre class="inline_code">INT32</pre> Tensor. See <pre class="inline_code">fequal_g</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
FGraphNode *fequal_cf(FGraphNode *a, const float b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Compares a tensor and a constant elementwise by <pre class="inline_code">a = b</pre> and returns a 0,1
 <pre class="inline_code">INT32</pre> Tensor. See <pre class="inline_code">fequal_g</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
FGraphNode *fequal_cd(FGraphNode *a, const double b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Compares a tensor and a constant elementwise by <pre class="inline_code">a = b</pre> and returns a 0,1
 <pre class="inline_code">INT32</pre> Tensor. See <pre class="inline_code">fequal_g</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
FGraphNode *fmatmul(FGraphNode *a, FGraphNode *b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Carries out matrix multiplication on the last two dimensions of the tensors.

 E.g. a matrix multiplication of two tensors with shapes <pre class="inline_code">(64, 32, 16)</pre> and
 <pre class="inline_code">(16, 24)</pre> will yield a tensor with shape <pre class="inline_code">(64, 32, 24)</pre>.

 Since for one entry of the
 tensor multiple other previous entries are needed, the operand tensors need
 to be executed first. Therefor the method will implicitly (or eagerly)
 execute the two parameter nodes <pre class="inline_code">a</pre> and <pre class="inline_code">b</pre> if their data is not allready
 present, the given pointers will be overwritten with the results. </div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
FGraphNode *fflatten(FGraphNode *a)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Flattens the complete tensor to a tensor with one
dimension.
E.g.<pre class="inline_code">flattened([[[3, 1, 4], [2, 1, 5]], [[0, 4, 2], [4, 7, 9]]]) = [3, 1, 4, 2,
1, 5, 0, 4, 2, 4, 7, 9]</pre>.
</div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
FGraphNode *fflatten_dimension(FGraphNode *a, int dimension)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Flattens a tensor <pre class="inline_code">a</pre> with <pre class="inline_code">n</pre> dimensions along
<pre class="inline_code">dimension</pre>, resulting in a tensor with <pre class="inline_code">n-1</pre> dimensions.
Flattening a dimension will remove it from the shape of the tensor, therefor its
not possible to flatten the dimension 0.
A Tensor <pre class="inline_code">[[[3, 1, 4], [2, 1, 5]], [[0, 4, 2], [4, 7, 9]]]</pre> flattened
along dimension 1 will result in <pre class="inline_code">[[3,1,4], [2,1,5], [0,4,2], [4,7,9]]</pre>.
</div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
FGraphNode *fconvert(FGraphNode *a, FType newtype)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Converts the data of <pre class="inline_code">a</pre> to the type given by <pre class="inline_code">newtype</pre></div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
FGraphNode *freshape(FGraphNode *a, size_t *newshape, int dimensions)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Reshapes the underlying data of the tensor to the new shape. The product of
each dimension of the new shape must be the same as the product of the
dimensions of the previous shape (i.e. it must describe the same number of
entries of the tensor).</div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
FGraphNode *fmin_g(FGraphNode *a, FGraphNode *b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Takes the minimum of two tensors element wise along the last dimension of
 each, i.e. <pre class="inline_code">a[i]</pre> if <pre class="inline_code">a[i] < b[i]</pre> else <pre class="inline_code">b[i]</pre> </div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
FGraphNode *fmin_ci(FGraphNode *a, const int b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Takes the minimum of two tensors element wise along the last dimension of
 each, i.e. <pre class="inline_code">a[i]</pre> if <pre class="inline_code">a[i] < b</pre> else <pre class="inline_code">b</pre> </div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
FGraphNode *fmin_cl(FGraphNode *a, const long b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Takes the minimum of two tensors element wise along the last dimension of
 each, i.e. <pre class="inline_code">a[i]</pre> if <pre class="inline_code">a[i] < b</pre> else <pre class="inline_code">b</pre> </div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
FGraphNode *fmin_cf(FGraphNode *a, const float b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Takes the minimum of two tensors element wise along the last dimension of
 each, i.e. <pre class="inline_code">a[i]</pre> if <pre class="inline_code">a[i] < b</pre> else <pre class="inline_code">b</pre> </div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
FGraphNode *fmin_cd(FGraphNode *a, const double b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Takes the minimum of two tensors element wise along the last dimension of
 each, i.e. <pre class="inline_code">a[i]</pre> if <pre class="inline_code">a[i] < b</pre> else <pre class="inline_code">b</pre> </div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
FGraphNode *fmax_g(FGraphNode *a, FGraphNode *b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Takes the maximum of two tensors element wise along the last dimension of
 each, i.e. <pre class="inline_code">a[i]</pre> if <pre class="inline_code">a[i] > b[i]</pre> else <pre class="inline_code">b[i]</pre> </div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
FGraphNode *fmax_ci(FGraphNode *a, const int b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Takes the maximum of two tensors element wise along the last dimension of
 each, i.e. <pre class="inline_code">a[i]</pre> if <pre class="inline_code">a[i] > b</pre> else <pre class="inline_code">b</pre> </div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
FGraphNode *fmax_cl(FGraphNode *a, const long b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Takes the maximum of two tensors element wise along the last dimension of
 each, i.e. <pre class="inline_code">a[i]</pre> if <pre class="inline_code">a[i] > b</pre> else <pre class="inline_code">b</pre> </div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
FGraphNode *fmax_cf(FGraphNode *a, const float b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Takes the maximum of two tensors element wise along the last dimension of
 each, i.e. <pre class="inline_code">a[i]</pre> if <pre class="inline_code">a[i] > b</pre> else <pre class="inline_code">b</pre> </div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
FGraphNode *fmax_cd(FGraphNode *a, const double b)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Takes the maximum of two tensors element wise along the last dimension of
 each, i.e. <pre class="inline_code">a[i]</pre> if <pre class="inline_code">a[i] > b</pre> else <pre class="inline_code">b</pre> </div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
FGraphNode *freduce_sum(FGraphNode *a, const int dimension)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Reduces one dimension of the tensor by additive folding e.g.

 <pre class="inline_code">freduce_sum([[1,2,3], [4,5,6]], 0) = [5,7,9]</pre>,
 <pre class="inline_code">freduce_sum([[1,2,3], [4,5,6]], 1) = [6,15]</pre>

 The results of the predecessor node must be available, to
 ensure that the method may execute the parameter node. The corresponding
 result is then stored in the memory pointed to by <pre class="inline_code">a</pre>. </div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
FGraphNode *freduce_mul(FGraphNode *a, const int dimension)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Reduces one dimension of the tensor by multiplicative folding e.g.

 <pre class="inline_code">freduce_mul([[1,2,3], [4,5,6]], 0) = [4,10,18]</pre>,
 <pre class="inline_code">freduce_mul([[1,2,3], [4,5,6]], 1) = [6, 120]</pre>

 The results of the predecessor node must be available; to
 ensure that the method may execute the parameter node. The corresponding
 result is then stored in the memory pointed to by a. </div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
FGraphNode *fslice(FGraphNode *a, const long *start, const long *end)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Selects a slice of the tensor with a dimension wise start and end index.
 <pre class="inline_code">start</pre> and <pre class="inline_code">end</pre> are arrays with as many entries
 as the tensor has dimensions. They may contain negative values,
 which are then subtracted from the end of the tensor (e.g. <pre class="inline_code">-1</pre> means the
 last element). <pre class="inline_code">start</pre> is inclusive and describes the start index of the
 selection per dimension and <pre class="inline_code">end</pre> describes the end index per dimension
 and is inclusive as well.
</div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
FGraphNode *fslice_step(FGraphNode *a, const long *start, const long *end,
                        const long *step)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Selects a slice of the tensor with a dimension wise start index, end index
 and step size. <pre class="inline_code">start</pre>, <pre class="inline_code">end</pre> and <pre class="inline_code">step</pre> are arrays with as
 many entries as the tensor has dimensions. <pre class="inline_code">start</pre> and <pre class="inline_code">end</pre> may
 contain negative values, which are then subtracted from the end of the tensor
 (e.g. <pre class="inline_code">-1</pre> means the last element). <pre class="inline_code">start</pre> is inclusive and describes the
 start index of the selection per dimension and <pre class="inline_code">end</pre> describes the end
 index per dimension and is inclusive as well. <pre class="inline_code">step</pre> contains the per
 dimension step size (e.g. <pre class="inline_code">2</pre> meaning every second element will be selected
 etc.) and may be negative as well, which reverses the traversal order (the
 first elements are selected as the last ones). For a negative step size,
 <pre class="inline_code">start > end</pre> must hold (for a positive of course <pre class="inline_code">end >
 start</pre>) for each dimension.
</div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
FGraphNode *fabs_g(FGraphNode *a)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Takes the elementwise absolute value of <pre class="inline_code">a</pre>, i.e. <pre class="inline_code">|a[i]|</pre> </div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
FGraphNode *frepeat(FGraphNode *a, int *repititions)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Repeats dimensions of a tensor multiple times
<ul><li><pre class="inline_code">a</pre>: the node in which dimensions are to be repeated
</li><li><pre class="inline_code">repititions</pre>: array with the same number of entries as the tensor has
    dimensions
</li></ul> e.g. <pre class="inline_code">repeat([[0,1], [2,3]], [2, 3]) = [[0,1,0,1,0,1],
 [2,3,2,3,2,3], [0,1,0,1,0,1], [2,3,2,3,2,3]]</pre>
</div></div><div style="display: block; height: 2em;"></div>
<div class="card"><pre class="card_header_code">
FGraphNode *ftranspose(FGraphNode *a, int *transpositions)</pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Transposes this tensor along multiple dimensions
<ul><li><pre class="inline_code">a</pre>: the node which should be transposed
</li><li><pre class="inline_code">transpositions</pre>: an array with the same number of entries as the tensor
   has dimensions, which gives the perumtation of dimensions.
</li></ul> The tensor will have a resulting shape in which the size in dimension <pre class="inline_code">i</pre>
 corresponds to the former size in dimension <pre class="inline_code">transpositions[i]</pre>.
</div></div><div style="display: block; height: 2em;"></div>

    </div>
</center>
  <div id="footer">
    <center>
    <div class="content">
      <div class="row">
        <div class="column">
           David Schwarzbeck, 2022</br>
          Licensed under the <a href="https://github.com/Frobeniusnorm/Flint/blob/main/LICENCE">Apache License</a>, Version 2.0
        </div>
        <div class="column">&nbsp;</div>
        <div class="column">&nbsp;</div>
        <div class="column">
          <a href="https://github.com/Frobeniusnorm/Flint/">Github</a>
        </div>
      </div>
    </div>
    </center>
  </div>
</body>
</html>
