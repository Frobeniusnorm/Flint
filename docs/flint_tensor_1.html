<!DOCTYPE html>
<html>
<head>
  <title>
    Flint Documentation
  </title>
  <link rel="stylesheet" href="style.css" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
</head>

<body>

  <div id="header-bar">
    <div class="left-spaced">
      <img src="flint.png" style="width:5.2em; height:3em; display: inline-block; vertical-align: middle;" />
      <a class="item" href="index.html">About</a>
      <a class="item selected" href="documentation.html">Documentation</a>
      <a class="item">Tutorial</a>
    </div>
  </div>
  <div id="showcase_background" style="min-height: 18em; background: linear-gradient(90deg, rgba(2,0,36,1) 0%, rgba(214,103,61,1) 0%, rgba(159,33,228,1) 100%);">
    <center style="margin-top:2em">
      <h1>
        Documentation <u>flint.hpp</u>
      </h1>
      <div style="display: block; height: 0.5em;"></div>
      <h2>
        Tensor&lt;T, 1&gt;
      </h2>
    </center>
  </div>
  <center>
<div class="content" style="margin-top: -3.1em">
        <div class="card">    <span class="card_header">Overview</span></div><br /><div class="card"><span class="card_header" style="font-size:1.2em">Types</span><ul><li><a href="#s-_typename_T__struct_Tensor_T__1__">template &lt;typename T&gt; struct <b>Tensor</b></a></li></ul><span class="card_header" style="font-size:1.2em">Functions</span><ul><li><a href="#s-data__:_shape"><b>Tensor</b>(storage_type data) : shape</a></li><li><a href="#s-data__:_shape"><b>Tensor</b>(init_type data) : shape</a></li><li><a href="#s-Tensor_&other__"><b>Tensor</b>(const Tensor &other) </a></li><li><a href="#s-operator=_const_Tensor_T__1__&other__">void <b>operator=</b>(const Tensor<T, 1> &other) </a></li><li><a href="#s-operator=_Tensor_&&other__">void <b>operator=</b>(Tensor &&other) </a></li><li><a href="#s-"><b>~Tensor</b>() </a></li><li><a href="#s-&operator[]_const_size_t_index__">T <b>&operator[]</b>(const size_t index) </a></li><li><a href="#s-Tensor_T__1__constant_T_value__size_t_size__">static Tensor&lt;T, 1&gt; <b>constant</b>(T value, size_t size) </a></li><li><a href="#s-1__reduce_sum___">Tensor&lt;T, 1&gt; <b>reduce_sum</b>() </a></li><li><a href="#s-1__reduce_mul___">Tensor&lt;T, 1&gt; <b>reduce_mul</b>() </a></li><li><a href="#s-size_t_get_shape___const_">const size_t <b>get_shape</b>() const </a></li><li><a href="#s-operator*___">std::vector&lt;T&gt; <b>operator*</b>() </a></li><li><a href="#s-execute___">void <b>execute</b>() </a></li><li><a href="#s-execute_cpu___">void <b>execute_cpu</b>() </a></li><li><a href="#s-execute_gpu___">void <b>execute_gpu</b>() </a></li><li><a href="#s-1__&operator_____">Tensor&lt;T, 1&gt; <b>&operator</b>()() </a></li><li><a href="#s-1__operator-___const_">Tensor&lt;T, 1&gt; <b>operator-</b>() const </a></li><li><a href="#s-1__sign___const_">Tensor&lt;int, 1&gt; <b>sign</b>() const </a></li><li><a href="#s-1__even___const_">Tensor&lt;int, 1&gt; <b>even</b>() const </a></li><li><a href="#s-std::string___">operator <b>std::string</b>() </a></li><li><a href="#s-std::ostream_&operator___std::ostream_&os__Tensor_T__1__&t__">friend std::ostream <b>&operator&lt;&lt;</b>(std::ostream &os, Tensor<T, 1> &t) </a></li><li><a href="#s-_typename_K__unsigned_int_k___Tensor_stronger_return_K___k__operator+_const_Tensor_K__k__&other__const_">template &lt;typename K, unsigned int k&gt;
  Tensor&lt;stronger_return&lt;K&gt;, k&gt; <b>operator+</b>(const Tensor<K, k> &other) const </a></li><li><a href="#s-_typename_K___Tensor_stronger_return_K___1__operator+_const_K_con__const_">template &lt;typename K&gt;
  Tensor&lt;stronger_return&lt;K&gt;, 1&gt; <b>operator+</b>(const K con) const </a></li><li><a href="#s-_typename_K__unsigned_int_k___Tensor_stronger_return_K___k__operator-_const_Tensor_K__k__&other__const_">template &lt;typename K, unsigned int k&gt;
  Tensor&lt;stronger_return&lt;K&gt;, k&gt; <b>operator-</b>(const Tensor<K, k> &other) const </a></li><li><a href="#s-_typename_K___Tensor_stronger_return_K___1__operator-_const_K_con__const_">template &lt;typename K&gt;
  Tensor&lt;stronger_return&lt;K&gt;, 1&gt; <b>operator-</b>(const K con) const </a></li><li><a href="#s-_typename_K__unsigned_int_k___Tensor_stronger_return_K___k__operator*_const_Tensor_K__k__&other__const_">template &lt;typename K, unsigned int k&gt;
  Tensor&lt;stronger_return&lt;K&gt;, k&gt; <b>operator*</b>(const Tensor<K, k> &other) const </a></li><li><a href="#s-_typename_K___Tensor_stronger_return_K___1__operator*_const_K_con__const_">template &lt;typename K&gt;
  Tensor&lt;stronger_return&lt;K&gt;, 1&gt; <b>operator*</b>(const K con) const </a></li><li><a href="#s-_typename_K__unsigned_int_k___Tensor_stronger_return_K___k__operator/_const_Tensor_K__k__&other__const_">template &lt;typename K, unsigned int k&gt;
  Tensor&lt;stronger_return&lt;K&gt;, k&gt; <b>operator/</b>(const Tensor<K, k> &other) const </a></li><li><a href="#s-_typename_K___Tensor_stronger_return_K___1__operator/_const_K_con__const_">template &lt;typename K&gt;
  Tensor&lt;stronger_return&lt;K&gt;, 1&gt; <b>operator/</b>(const K con) const </a></li><li><a href="#s-_typename_K__unsigned_int_k___Tensor_stronger_return_K___k__pow_const_Tensor_K__k__&other__const_">template &lt;typename K, unsigned int k&gt;
  Tensor&lt;stronger_return&lt;K&gt;, k&gt; <b>pow</b>(const Tensor<K, k> &other) const </a></li><li><a href="#s-_typename_K__Tensor_stronger_return_K___1__pow_const_K_other__const_">template &lt;typename K&gt; Tensor&lt;stronger_return&lt;K&gt;, 1&gt; <b>pow</b>(const K other) const </a></li><li><a href="#s-_typename_K__unsigned_int_k___Tensor_stronger_return_K___k__min_const_Tensor_K__k__&other__const_">template &lt;typename K, unsigned int k&gt;
  Tensor&lt;stronger_return&lt;K&gt;, k&gt; <b>min</b>(const Tensor<K, k> &other) const </a></li><li><a href="#s-_typename_K__Tensor_stronger_return_K___1__min_const_K_other__const_">template &lt;typename K&gt; Tensor&lt;stronger_return&lt;K&gt;, 1&gt; <b>min</b>(const K other) const </a></li><li><a href="#s-_typename_K__unsigned_int_k___Tensor_stronger_return_K___k__max_const_Tensor_K__k__&other__const_">template &lt;typename K, unsigned int k&gt;
  Tensor&lt;stronger_return&lt;K&gt;, k&gt; <b>max</b>(const Tensor<K, k> &other) const </a></li><li><a href="#s-_typename_K__Tensor_stronger_return_K___1__max_const_K_other__const_">template &lt;typename K&gt; Tensor&lt;stronger_return&lt;K&gt;, 1&gt; <b>max</b>(const K other) const </a></li><li><a href="#s-1__log___">Tensor&lt;to_float&lt;T&gt;, 1&gt; <b>log</b>() </a></li><li><a href="#s-1__log2___">Tensor&lt;to_float&lt;T&gt;, 1&gt; <b>log2</b>() </a></li><li><a href="#s-1__log10___">Tensor&lt;to_float&lt;T&gt;, 1&gt; <b>log10</b>() </a></li><li><a href="#s-1__sqrt___">Tensor&lt;to_float&lt;T&gt;, 1&gt; <b>sqrt</b>() </a></li><li><a href="#s-1__sin___">Tensor&lt;to_float&lt;T&gt;, 1&gt; <b>sin</b>() </a></li><li><a href="#s-1__cos___">Tensor&lt;to_float&lt;T&gt;, 1&gt; <b>cos</b>() </a></li><li><a href="#s-1__tan___">Tensor&lt;to_float&lt;T&gt;, 1&gt; <b>tan</b>() </a></li><li><a href="#s-1__asin___">Tensor&lt;to_float&lt;T&gt;, 1&gt; <b>asin</b>() </a></li><li><a href="#s-1__acos___">Tensor&lt;to_float&lt;T&gt;, 1&gt; <b>acos</b>() </a></li><li><a href="#s-1__atan___">Tensor&lt;to_float&lt;T&gt;, 1&gt; <b>atan</b>() </a></li><li><a href="#s-_typename_K__Tensor_K__1__convert___const_">template &lt;typename K&gt; Tensor&lt;K, 1&gt; <b>convert</b>() const </a></li><li><a href="#s-1__abs___const_">Tensor&lt;T, 1&gt; <b>abs</b>() const </a></li><li><a href="#s-_typename_K__unsigned_int_k___Tensor_int__k__operator__const_Tensor_K__k__&other__const_">template &lt;typename K, unsigned int k&gt;
  Tensor&lt;int, k&gt; <b>operator&lt;</b>(const Tensor<K, k> &other) const </a></li><li><a href="#s-_typename_K__Tensor_int__1__operator__const_K_other__const_">template &lt;typename K&gt; Tensor&lt;int, 1&gt; <b>operator&lt;</b>(const K other) const </a></li><li><a href="#s-_typename_K__unsigned_int_k___Tensor_int__1__operator__const_Tensor_K__k__&other__const_">template &lt;typename K, unsigned int k&gt;
  Tensor&lt;int, 1&gt; <b>operator&gt;</b>(const Tensor<K, k> &other) const </a></li><li><a href="#s-_typename_K__Tensor_int__1__operator__const_K_other__const_">template &lt;typename K&gt; Tensor&lt;int, 1&gt; <b>operator&gt;</b>(const K other) const </a></li><li><a href="#s-_typename_K__unsigned_int_k___Tensor_int__k__equal_const_Tensor_K__k__&other__const_">template &lt;typename K, unsigned int k&gt;
  Tensor&lt;int, k&gt; <b>equal</b>(const Tensor<K, k> &other) const </a></li><li><a href="#s-_typename_K__Tensor_int__1__equal_const_K_other__const_">template &lt;typename K&gt; Tensor&lt;int, 1&gt; <b>equal</b>(const K other) const </a></li><li><a href="#s-1__slice_long_start_=_0__long_end_=_TensorRange::MAX_SCOPE______________________long_step_=_1__const_">Tensor&lt;T, 1&gt; <b>slice</b>(long start = 0, long end = TensorRange::MAX_SCOPE,
                     long step = 1) const </a></li><li><a href="#s-get_graph_node___const_">FGraphNode <b>*get_graph_node</b>() const </a></li><li><a href="#s-1__repeat_int_repetitions__const_">Tensor&lt;T, 1&gt; <b>repeat</b>(int repetitions) const </a></li><li><a href="#s-_typename_K__unsigned_int_k___Tensor_double__k__gradient_const_Tensor_K__k__&dx__">template &lt;typename K, unsigned int k&gt;
  Tensor&lt;double, k&gt; <b>gradient</b>(const Tensor<K, k> &dx) </a></li></ul></div>
        <div style="display: block; height: 2em;"></div>
        <div id="s-_typename_T__struct_Tensor_T__1__"></div><div class="card"><pre class="card_header_code">template &lt;typename T&gt; struct <b>Tensor</b></pre></div>
<br />
<div class="card"><div style="padding: 5px;">
 The 1 dimensional implementation of <pre class="inline_code">Tensor</pre>.
</div></div><div style="display: block; height: 2em;"></div>
<div id="s-data__:_shape"></div><div class="card"><pre class="card_header_code"><b>Tensor</b>(storage_type data) : shape</pre></div>
<br />
<div class="card"><div style="padding: 5px;">
 Creates a Tensor from a <pre class="inline_code">std::vector</pre>.
 (<pre class="inline_code">storage_type</pre> is a recursive defined type definition, for <pre class="inline_code">n=1</pre> it is
 just an alias for <pre class="inline_code">std::vector</pre>). E.g.<div style="display:block; height: 0.5em"></div>
 <pre class="card code" style="margin: 5px;">
 <span style="color: #FFF030">Tensor</span>&lt;<span style="color: #FFF030">float</span>, <span style="color: #30F0FF">1</span>&gt; t1{-<span style="color: #30F0FF">1</span>., <span style="color: #30F0FF">0</span>., <span style="color: #30F0FF">1</span>., <span style="color: #30F0FF">2</span>.};</pre>
</div></div><div style="display: block; height: 2em;"></div>
<div id="s-data__:_shape"></div><div class="card"><pre class="card_header_code"><b>Tensor</b>(init_type data) : shape</pre></div>
<br />
<div class="card"><div style="padding: 5px;">
 Creates a Tensor from a <pre class="inline_code">std::initializer_list</pre>.
 (<pre class="inline_code">init_type</pre> is a recursive defined type definition, for <pre class="inline_code">n=1</pre> it is just
 an alias for <pre class="inline_code">std::initializer_list</pre>). E.g.<div style="display:block; height: 0.5em"></div>
 <pre class="card code" style="margin: 5px;">
 <span style="color: #FFF030">Tensor</span>&lt;<span style="color: #FFF030">float</span>, <span style="color: #30F0FF">1</span>&gt; t(std::vector&lt;<span style="color: #FFF030">float</span>&gt;{-<span style="color: #30F0FF">1</span>., <span style="color: #30F0FF">0</span>., <span style="color: #30F0FF">1</span>., <span style="color: #30F0FF">2</span>.});</pre>
</div></div><div style="display: block; height: 2em;"></div>
<div id="s-Tensor_&other__"></div><div class="card"><pre class="card_header_code"><b>Tensor</b>(const Tensor &other) </pre></div>
<br />
<div class="card"><div style="padding: 5px;">
 Copy constructor. Copies the underlying Graph structure by creating a new
 node with the same operation, shape and data types. The new predecessor
 array points to the same predecessors (memory safety is ensured with
 reference counting).<div style="display:block; height: 0.5em"></div>
 If <pre class="inline_code">other</pre> has result data or if it is a storage node, the complete CPU
 data is directly copied. Since this operation is expensive it is advised to
 only use it if it is completly necessary.
</div></div><div style="display: block; height: 2em;"></div>
<div id="s-operator=_const_Tensor_T__1__&other__"></div><div class="card"><pre class="card_header_code">void <b>operator=</b>(const Tensor<T, 1> &other) </pre></div>
<br />
<div class="card"><div style="padding: 5px;">
 Copy operator. Copies the underlying Graph structure by creating a new
 node with the same operation, shape and data types. If there was any
 previous allocated operation node allocated by this Tensor it is cleaned
 up. The new predecessor array points to the same predecessors (memory
 safety is ensured with reference counting).<div style="display:block; height: 0.5em"></div>
 If <pre class="inline_code">other</pre> has result data or if it is a storage node, the complete CPU
 data is directly copied. Since this operation is expensive it is advised to
 only use it if it is completly necessary.
</div></div><div style="display: block; height: 2em;"></div>
<div id="s-operator=_Tensor_&&other__"></div><div class="card"><pre class="card_header_code">void <b>operator=</b>(Tensor &&other) </pre></div>
<br />
<div class="card"><div style="padding: 5px;">
 Move operator. Moves every important field from <pre class="inline_code">other</pre> to this Tensor.
 <pre class="inline_code">other</pre> is invalidated after this operation. If there was any previous
 allocated operation node allocated by this Tensor it is cleaned up.
</div></div><div style="display: block; height: 2em;"></div>
<div id="s-"></div><div class="card"><pre class="card_header_code"><b>~Tensor</b>() </pre></div>
<br />
<div class="card"><div style="padding: 5px;">
 Cleans up this tensor and frees all underlying data by reference counting.
</div></div><div style="display: block; height: 2em;"></div>
<div id="s-&operator[]_const_size_t_index__"></div><div class="card"><pre class="card_header_code">T <b>&operator[]</b>(const size_t index) </pre></div>
<br />
<div class="card"><div style="padding: 5px;">
 Indexes the Tensor and returns the element.
 If the underlying data is not yet computed, executes this Tensor.
</div></div><div style="display: block; height: 2em;"></div>
<div id="s-Tensor_T__1__constant_T_value__size_t_size__"></div><div class="card"><pre class="card_header_code">static Tensor&lt;T, 1&gt; <b>constant</b>(T value, size_t size) </pre></div>
<br />
<div class="card"><div style="padding: 5px;">
 Generates a Tensor containing the single given value in every entry.
 The resulting Tensor will have a dimensionality of 1 and a
 size denoted by <pre class="inline_code">size</pre>. e.g.<div style="display:block; height: 0.5em"></div>
 <pre class="card code" style="margin: 5px;">
 <span style="color: #FFF030">Tensor</span>&lt;<span style="color: #FFF030">double</span>, <span style="color: #30F0FF">1</span>&gt; foo = <span style="color: #FFF030">Tensor</span>&lt;<span style="color: #FFF030">double</span>, <span style="color: #30F0FF">1</span>&gt;::constant(<span style="color: #30F0FF">3</span>.<span style="color: #30F0FF">1</span><span style="color: #30F0FF">4</span><span style="color: #30F0FF">1</span><span style="color: #30F0FF">5</span><span style="color: #30F0FF">9</span><span style="color: #30F0FF">2</span>, <span style="color: #30F0FF">3</span>);
 std::cout &lt;&lt; foo &lt;&lt; std::endl;
 <span style="color: #D0D0D0">// Tensor&lt;FLOAT64, shape: <span style="color: #30F0FF">3</span>&gt;([<span style="color: #30F0FF">3</span>.<span style="color: #30F0FF">1</span><span style="color: #30F0FF">4</span><span style="color: #30F0FF">1</span><span style="color: #30F0FF">5</span><span style="color: #30F0FF">9</span><span style="color: #30F0FF">2</span>, <span style="color: #30F0FF">3</span>.<span style="color: #30F0FF">1</span><span style="color: #30F0FF">4</span><span style="color: #30F0FF">1</span><span style="color: #30F0FF">5</span><span style="color: #30F0FF">9</span><span style="color: #30F0FF">2</span>, <span style="color: #30F0FF">3</span>.<span style="color: #30F0FF">1</span><span style="color: #30F0FF">4</span><span style="color: #30F0FF">1</span><span style="color: #30F0FF">5</span><span style="color: #30F0FF">9</span><span style="color: #30F0FF">2</span>])</span></pre>
</div></div><div style="display: block; height: 2em;"></div>
<div id="s-1__reduce_sum___"></div><div class="card"><pre class="card_header_code">Tensor&lt;T, 1&gt; <b>reduce_sum</b>() </pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Reduces one dimension of the tensor by additive folding e.g.<div style="display:block; height: 0.5em"></div>
 <pre class="card code" style="margin: 5px;">
 <span style="color: #FFF030">Tensor</span>&lt;<span style="color: #FFF030">int</span>, <span style="color: #30F0FF">1</span>&gt; a{<span style="color: #30F0FF">0</span>, <span style="color: #30F0FF">1</span>, <span style="color: #30F0FF">2</span>, <span style="color: #30F0FF">3</span>, <span style="color: #30F0FF">4</span>, <span style="color: #30F0FF">5</span>, <span style="color: #30F0FF">6</span>};
 std::cout &lt;&lt; (a.reduce_sum())() &lt;&lt; std::endl;
 <span style="color: #D0D0D0">// Tensor&lt;INT32, shape: <span style="color: #30F0FF">1</span>&gt;([<span style="color: #30F0FF">2</span><span style="color: #30F0FF">1</span>])</span></pre><div style="display:block; height: 0.5em"></div>
 The results of this Tensor must be available, to
 ensure that the method may execute the Tensor. </div></div><div style="display: block; height: 2em;"></div>
<div id="s-1__reduce_mul___"></div><div class="card"><pre class="card_header_code">Tensor&lt;T, 1&gt; <b>reduce_mul</b>() </pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Reduces one dimension of the tensor by multiplicative folding e.g.<div style="display:block; height: 0.5em"></div>
 <pre class="card code" style="margin: 5px;">
 <span style="color: #FFF030">Tensor</span>&lt;<span style="color: #FFF030">int</span>, <span style="color: #30F0FF">1</span>&gt; a{<span style="color: #30F0FF">1</span>, <span style="color: #30F0FF">2</span>, <span style="color: #30F0FF">3</span>, <span style="color: #30F0FF">4</span>};
 std::cout &lt;&lt; (a.reduce_mul())() &lt;&lt; std::endl;
 <span style="color: #D0D0D0">// Tensor&lt;INT32, shape: <span style="color: #30F0FF">1</span>&gt;([<span style="color: #30F0FF">2</span><span style="color: #30F0FF">4</span>])</span></pre><div style="display:block; height: 0.5em"></div>
 The results of this Tensor must be available, to
 ensure that the method may execute the Tensor. </div></div><div style="display: block; height: 2em;"></div>
<div id="s-size_t_get_shape___const_"></div><div class="card"><pre class="card_header_code">const size_t <b>get_shape</b>() const </pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Returns the number of entries in this Tensor </div></div><div style="display: block; height: 2em;"></div>
<div id="s-operator*___"></div><div class="card"><pre class="card_header_code">std::vector&lt;T&gt; <b>operator*</b>() </pre></div>
<br />
<div class="card"><div style="padding: 5px;">
 Retrieves the data of the current node and converts it into a vector.
 Executes the node if necessary (if it was not executed prior). This
 operation has to duplicate the complete data. Since that is a memory heavy
 and slow operation, it is recommended to use the index operator
 <pre class="inline_code">operator[]</pre> whenever possible instead. E.g.<div style="display:block; height: 0.5em"></div>
 <pre class="card code" style="margin: 5px;">
 <span style="color: #FFF030">Tensor</span>&lt;<span style="color: #FFF030">int</span>, <span style="color: #30F0FF">1</span>&gt; foo = <span style="color: #FFF030">Tensor</span>&lt;<span style="color: #FFF030">int</span>, <span style="color: #30F0FF">1</span>&gt;::constant(<span style="color: #30F0FF">4</span><span style="color: #30F0FF">2</span>, <span style="color: #30F0FF">5</span>);
 std::vector&lt;<span style="color: #FFF030">int</span>&gt; foo_res = *foo;
 <span style="color: #D0D0D0">// foo_res = {<span style="color: #30F0FF">4</span><span style="color: #30F0FF">2</span>, <span style="color: #30F0FF">4</span><span style="color: #30F0FF">2</span>, <span style="color: #30F0FF">4</span><span style="color: #30F0FF">2</span>, <span style="color: #30F0FF">4</span><span style="color: #30F0FF">2</span>, <span style="color: #30F0FF">4</span><span style="color: #30F0FF">2</span>}</span></pre>
</div></div><div style="display: block; height: 2em;"></div>
<div id="s-execute___"></div><div class="card"><pre class="card_header_code">void <b>execute</b>() </pre></div>
<br />
<div class="card"><div style="padding: 5px;">
 Executes the underlying operation (and lazily the operations of the parents
 if needed) if it was not already executed prior (in that case the operation
 does nothing).
 If Flint was initiallized implicitly (without ever calling <pre class="inline_code">flintInit</pre>) or
 with <pre class="inline_code">FLINT_BACKEND_BOTH</pre> the backend is chosen automatically by heuristics
 and initialized if it was not prior.
</div></div><div style="display: block; height: 2em;"></div>
<div id="s-execute_cpu___"></div><div class="card"><pre class="card_header_code">void <b>execute_cpu</b>() </pre></div>
<br />
<div class="card"><div style="padding: 5px;">
 Executes the underlying operation (and lazily the operations of the parents
 if needed) if it was not already executed prior (in that case the operation
 does nothing).
 Uses the CPU backend and initializes it if it was not initialized.
</div></div><div style="display: block; height: 2em;"></div>
<div id="s-execute_gpu___"></div><div class="card"><pre class="card_header_code">void <b>execute_gpu</b>() </pre></div>
<br />
<div class="card"><div style="padding: 5px;">
 Executes the underlying operation (and lazily the operations of the parents
 if needed) if it was not already executed prior (in that case the operation
 does nothing).
 Uses the CPU backend and initializes it if it was not initialized.
</div></div><div style="display: block; height: 2em;"></div>
<div id="s-1__&operator_____"></div><div class="card"><pre class="card_header_code">Tensor&lt;T, 1&gt; <b>&operator</b>()() </pre></div>
<br />
<div class="card"><div style="padding: 5px;">
 Convenience Method that calls <pre class="inline_code">execute</pre> and returns the Tensor object
 (the same, no new node is created!).
</div></div><div style="display: block; height: 2em;"></div>
<div id="s-1__operator-___const_"></div><div class="card"><pre class="card_header_code">Tensor&lt;T, 1&gt; <b>operator-</b>() const </pre></div>
<br />
<div class="card"><div style="padding: 5px;">
 Negates the elements of this Tensor.
 E.g.<div style="display:block; height: 0.5em"></div>
 <pre class="card code" style="margin: 5px;">
 <span style="color: #FFF030">Tensor</span>&lt;<span style="color: #FFF030">float</span>, <span style="color: #30F0FF">1</span>&gt; foo = {-<span style="color: #30F0FF">3</span>, <span style="color: #30F0FF">3</span>.<span style="color: #30F0FF">1</span><span style="color: #30F0FF">4</span><span style="color: #30F0FF">1</span><span style="color: #30F0FF">5</span><span style="color: #30F0FF">9</span><span style="color: #30F0FF">2</span>, <span style="color: #30F0FF">4</span><span style="color: #30F0FF">2</span>.<span style="color: #30F0FF">0</span><span style="color: #30F0FF">7</span><span style="color: #30F0FF">9</span><span style="color: #30F0FF">8</span>, -<span style="color: #30F0FF">4</span>.<span style="color: #30F0FF">3</span>};
 std::cout &lt;&lt; (-foo)() &lt;&lt; std::endl;
 <span style="color: #D0D0D0">// Tensor&lt;FLOAT32, shape: <span style="color: #30F0FF">4</span>&gt;([<span style="color: #30F0FF">3</span>.<span style="color: #30F0FF">0</span><span style="color: #30F0FF">0</span><span style="color: #30F0FF">0</span><span style="color: #30F0FF">0</span><span style="color: #30F0FF">0</span><span style="color: #30F0FF">0</span>, -<span style="color: #30F0FF">3</span>.<span style="color: #30F0FF">1</span><span style="color: #30F0FF">4</span><span style="color: #30F0FF">1</span><span style="color: #30F0FF">5</span><span style="color: #30F0FF">9</span><span style="color: #30F0FF">2</span>, -<span style="color: #30F0FF">4</span><span style="color: #30F0FF">2</span>.<span style="color: #30F0FF">0</span><span style="color: #30F0FF">7</span><span style="color: #30F0FF">9</span><span style="color: #30F0FF">8</span><span style="color: #30F0FF">0</span><span style="color: #30F0FF">0</span>, <span style="color: #30F0FF">4</span>.<span style="color: #30F0FF">3</span><span style="color: #30F0FF">0</span><span style="color: #30F0FF">0</span><span style="color: #30F0FF">0</span><span style="color: #30F0FF">0</span><span style="color: #30F0FF">0</span>])</span></pre>
</div></div><div style="display: block; height: 2em;"></div>
<div id="s-1__sign___const_"></div><div class="card"><pre class="card_header_code">Tensor&lt;int, 1&gt; <b>sign</b>() const </pre></div>
<br />
<div class="card"><div style="padding: 5px;">
 Returns a tensor <pre class="inline_code">x</pre> with the shape of a with <pre class="inline_code">x[i] = 1</pre> if <pre class="inline_code">a[i] &gt;= 0</pre>
 else <pre class="inline_code">x[i] = -1</pre>. If you need to distinguish additionally for 0 values,
 take a look at <pre class="inline_code">equal</pre>. E.g.<div style="display:block; height: 0.5em"></div>
 <pre class="card code" style="margin: 5px;">
 <span style="color: #FFF030">Tensor</span>&lt;<span style="color: #FFF030">float</span>, <span style="color: #30F0FF">1</span>&gt; foo = {-<span style="color: #30F0FF">3</span>, <span style="color: #30F0FF">3</span>.<span style="color: #30F0FF">1</span><span style="color: #30F0FF">4</span><span style="color: #30F0FF">1</span><span style="color: #30F0FF">5</span><span style="color: #30F0FF">9</span><span style="color: #30F0FF">2</span>, <span style="color: #30F0FF">4</span><span style="color: #30F0FF">2</span>.<span style="color: #30F0FF">0</span><span style="color: #30F0FF">7</span><span style="color: #30F0FF">9</span><span style="color: #30F0FF">8</span>, -<span style="color: #30F0FF">4</span>.<span style="color: #30F0FF">3</span>};
 std::cout &lt;&lt; (foo.sign())() &lt;&lt; std::endl;
 <span style="color: #D0D0D0">// Tensor&lt;INT32, shape: <span style="color: #30F0FF">4</span>&gt;([-<span style="color: #30F0FF">1</span>, <span style="color: #30F0FF">1</span>, <span style="color: #30F0FF">1</span>, -<span style="color: #30F0FF">1</span>])</span></pre>
</div></div><div style="display: block; height: 2em;"></div>
<div id="s-1__even___const_"></div><div class="card"><pre class="card_header_code">Tensor&lt;int, 1&gt; <b>even</b>() const </pre></div>
<br />
<div class="card"><div style="padding: 5px;">
 Returns a int tensor <pre class="inline_code">x</pre> with the shape of <pre class="inline_code">this</pre> with <pre class="inline_code">x[i] = 1</pre> if
 <pre class="inline_code">this[i] % 2 = 0</pre> else <pre class="inline_code">x[i] = 0</pre>. This Tensor needs to have a integer
 type. E.g.<div style="display:block; height: 0.5em"></div>
 <pre class="card code" style="margin: 5px;">
 <span style="color: #FFF030">Tensor</span>&lt;<span style="color: #FFF030">int</span>, <span style="color: #30F0FF">1</span>&gt; foo = {<span style="color: #30F0FF">2</span>, <span style="color: #30F0FF">3</span>, <span style="color: #30F0FF">4</span><span style="color: #30F0FF">2</span>, <span style="color: #30F0FF">7</span>};
 std::cout &lt;&lt; (foo.even())() &lt;&lt; std::endl;
 <span style="color: #D0D0D0">// Tensor&lt;INT32, shape: <span style="color: #30F0FF">4</span>&gt;([<span style="color: #30F0FF">1</span>, <span style="color: #30F0FF">0</span>, <span style="color: #30F0FF">1</span>, <span style="color: #30F0FF">0</span>])</span></pre>
</div></div><div style="display: block; height: 2em;"></div>
<div id="s-std::string___"></div><div class="card"><pre class="card_header_code">operator <b>std::string</b>() </pre></div>
<br />
<div class="card"><div style="padding: 5px;">
 Converts this Tensor to a string representation.
 If the Tensor was not yet executed, it won't be, instead of the data it
 will say "&lt;not yet executed&gt;".
</div></div><div style="display: block; height: 2em;"></div>
<div id="s-std::ostream_&operator___std::ostream_&os__Tensor_T__1__&t__"></div><div class="card"><pre class="card_header_code">friend std::ostream <b>&operator&lt;&lt;</b>(std::ostream &os, Tensor<T, 1> &t) </pre></div>
<br />
<div class="card"><div style="padding: 5px;">
 Calls <pre class="inline_code">std::string()</pre> on this Tensor and pipes the returned string to the
 pipe.
</div></div><div style="display: block; height: 2em;"></div>
<div id="s-_typename_K__unsigned_int_k___Tensor_stronger_return_K___k__operator+_const_Tensor_K__k__&other__const_"></div><div class="card"><pre class="card_header_code">template &lt;typename K, unsigned int k&gt;
  Tensor&lt;stronger_return&lt;K&gt;, k&gt; <b>operator+</b>(const Tensor<K, k> &other) const </pre></div>
<br />
<div class="card"><div style="padding: 5px;">
 Elementwise addition of this Tensor and <pre class="inline_code">other</pre>.
 The datatype of the result is the datatype with
 higher precedence.
 </div></div><div style="display: block; height: 2em;"></div>
<div id="s-_typename_K___Tensor_stronger_return_K___1__operator+_const_K_con__const_"></div><div class="card"><pre class="card_header_code">template &lt;typename K&gt;
  Tensor&lt;stronger_return&lt;K&gt;, 1&gt; <b>operator+</b>(const K con) const </pre></div>
<br />
<div class="card"><div style="padding: 5px;">
 Elementwise addition of the constant <pre class="inline_code">other</pre> to this Tensor.
 If the datatype of <pre class="inline_code">K</pre> is stronger (stronger precedence) than the datatype
 of this Tensor <pre class="inline_code">T</pre>, <pre class="inline_code">K</pre> will be the result type, else <pre class="inline_code">T</pre>.
</div></div><div style="display: block; height: 2em;"></div>
<div id="s-_typename_K__unsigned_int_k___Tensor_stronger_return_K___k__operator-_const_Tensor_K__k__&other__const_"></div><div class="card"><pre class="card_header_code">template &lt;typename K, unsigned int k&gt;
  Tensor&lt;stronger_return&lt;K&gt;, k&gt; <b>operator-</b>(const Tensor<K, k> &other) const </pre></div>
<br />
<div class="card"><div style="padding: 5px;">
 Elementwise substraction of this Tensor and <pre class="inline_code">other</pre>.
 The datatype of the result is the datatype with
 higher precedence.
 </div></div><div style="display: block; height: 2em;"></div>
<div id="s-_typename_K___Tensor_stronger_return_K___1__operator-_const_K_con__const_"></div><div class="card"><pre class="card_header_code">template &lt;typename K&gt;
  Tensor&lt;stronger_return&lt;K&gt;, 1&gt; <b>operator-</b>(const K con) const </pre></div>
<br />
<div class="card"><div style="padding: 5px;">
 Elementwise substraction of this Tensor and the constant <pre class="inline_code">other</pre>.
 If the datatype of <pre class="inline_code">K</pre> is stronger (stronger precedence) than the datatype
 of this Tensor <pre class="inline_code">T</pre>, <pre class="inline_code">K</pre> will be the result type, else <pre class="inline_code">T</pre>.
</div></div><div style="display: block; height: 2em;"></div>
<div id="s-_typename_K__unsigned_int_k___Tensor_stronger_return_K___k__operator*_const_Tensor_K__k__&other__const_"></div><div class="card"><pre class="card_header_code">template &lt;typename K, unsigned int k&gt;
  Tensor&lt;stronger_return&lt;K&gt;, k&gt; <b>operator*</b>(const Tensor<K, k> &other) const </pre></div>
<br />
<div class="card"><div style="padding: 5px;">
 Elementwise multiplication of this Tensor and <pre class="inline_code">other</pre>.
 The datatype of the result is the datatype with
 higher precedence.
 </div></div><div style="display: block; height: 2em;"></div>
<div id="s-_typename_K___Tensor_stronger_return_K___1__operator*_const_K_con__const_"></div><div class="card"><pre class="card_header_code">template &lt;typename K&gt;
  Tensor&lt;stronger_return&lt;K&gt;, 1&gt; <b>operator*</b>(const K con) const </pre></div>
<br />
<div class="card"><div style="padding: 5px;">
 Elementwise multiplication of this Tensor and the constant <pre class="inline_code">other</pre>.
 If the datatype of <pre class="inline_code">K</pre> is stronger (stronger precedence) than the datatype
 of this Tensor <pre class="inline_code">T</pre>, <pre class="inline_code">K</pre> will be the result type, else <pre class="inline_code">T</pre>.
</div></div><div style="display: block; height: 2em;"></div>
<div id="s-_typename_K__unsigned_int_k___Tensor_stronger_return_K___k__operator/_const_Tensor_K__k__&other__const_"></div><div class="card"><pre class="card_header_code">template &lt;typename K, unsigned int k&gt;
  Tensor&lt;stronger_return&lt;K&gt;, k&gt; <b>operator/</b>(const Tensor<K, k> &other) const </pre></div>
<br />
<div class="card"><div style="padding: 5px;">
 Elementwise division of this Tensor and <pre class="inline_code">other</pre>.
 The datatype of the result is the datatype with
 higher precedence.
 </div></div><div style="display: block; height: 2em;"></div>
<div id="s-_typename_K___Tensor_stronger_return_K___1__operator/_const_K_con__const_"></div><div class="card"><pre class="card_header_code">template &lt;typename K&gt;
  Tensor&lt;stronger_return&lt;K&gt;, 1&gt; <b>operator/</b>(const K con) const </pre></div>
<br />
<div class="card"><div style="padding: 5px;">
 Elementwise division of this Tensor and the constant <pre class="inline_code">other</pre>.
 If the datatype of <pre class="inline_code">K</pre> is stronger (stronger precedence) than the datatype
 of this Tensor <pre class="inline_code">T</pre>, <pre class="inline_code">K</pre> will be the result type, else <pre class="inline_code">T</pre>.
</div></div><div style="display: block; height: 2em;"></div>
<div id="s-_typename_K__unsigned_int_k___Tensor_stronger_return_K___k__pow_const_Tensor_K__k__&other__const_"></div><div class="card"><pre class="card_header_code">template &lt;typename K, unsigned int k&gt;
  Tensor&lt;stronger_return&lt;K&gt;, k&gt; <b>pow</b>(const Tensor<K, k> &other) const </pre></div>
<br />
<div class="card"><div style="padding: 5px;">
 Takes the elementwise power of this Tensor to <pre class="inline_code">other</pre>.
 The datatype of the result is the datatype with
 higher precedence.
 </div></div><div style="display: block; height: 2em;"></div>
<div id="s-_typename_K__Tensor_stronger_return_K___1__pow_const_K_other__const_"></div><div class="card"><pre class="card_header_code">template &lt;typename K&gt; Tensor&lt;stronger_return&lt;K&gt;, 1&gt; <b>pow</b>(const K other) const </pre></div>
<br />
<div class="card"><div style="padding: 5px;">
 Takes the elementwise power of this Tensor to the constant <pre class="inline_code">other</pre>.
 If the datatype of <pre class="inline_code">K</pre> is stronger (stronger precedence) than the datatype
 of this Tensor <pre class="inline_code">T</pre>, <pre class="inline_code">K</pre> will be the result type, else <pre class="inline_code">T</pre>.
</div></div><div style="display: block; height: 2em;"></div>
<div id="s-_typename_K__unsigned_int_k___Tensor_stronger_return_K___k__min_const_Tensor_K__k__&other__const_"></div><div class="card"><pre class="card_header_code">template &lt;typename K, unsigned int k&gt;
  Tensor&lt;stronger_return&lt;K&gt;, k&gt; <b>min</b>(const Tensor<K, k> &other) const </pre></div>
<br />
<div class="card"><div style="padding: 5px;">
 Elementwise minimum of this Tensor and <pre class="inline_code">other</pre>. Per element either the
 entry of this Tensor or <pre class="inline_code">other</pre> is returned, depending on which is smaller.
 The datatype of the result is the datatype with
 higher precedence.
 </div></div><div style="display: block; height: 2em;"></div>
<div id="s-_typename_K__Tensor_stronger_return_K___1__min_const_K_other__const_"></div><div class="card"><pre class="card_header_code">template &lt;typename K&gt; Tensor&lt;stronger_return&lt;K&gt;, 1&gt; <b>min</b>(const K other) const </pre></div>
<br />
<div class="card"><div style="padding: 5px;">
 Elementwise minimum of this Tensor and the constant <pre class="inline_code">other</pre>. Per element
 either the entry of this Tensor or <pre class="inline_code">other</pre> is returned, depending on which
 is smaller. The datatype of the result is the datatype with higher
 precedence.
 </div></div><div style="display: block; height: 2em;"></div>
<div id="s-_typename_K__unsigned_int_k___Tensor_stronger_return_K___k__max_const_Tensor_K__k__&other__const_"></div><div class="card"><pre class="card_header_code">template &lt;typename K, unsigned int k&gt;
  Tensor&lt;stronger_return&lt;K&gt;, k&gt; <b>max</b>(const Tensor<K, k> &other) const </pre></div>
<br />
<div class="card"><div style="padding: 5px;">
 Elementwise maximum of this Tensor and <pre class="inline_code">other</pre>. Per element either the
 entry of this Tensor or <pre class="inline_code">other</pre> is returned, depending on which is larger.
 The datatype of the result is the datatype with
 higher precedence.
 </div></div><div style="display: block; height: 2em;"></div>
<div id="s-_typename_K__Tensor_stronger_return_K___1__max_const_K_other__const_"></div><div class="card"><pre class="card_header_code">template &lt;typename K&gt; Tensor&lt;stronger_return&lt;K&gt;, 1&gt; <b>max</b>(const K other) const </pre></div>
<br />
<div class="card"><div style="padding: 5px;">
 Elementwise maximum of this Tensor and the constant <pre class="inline_code">other</pre>. Per element
 either the entry of this Tensor or <pre class="inline_code">other</pre> is returned, depending on which
 is larger. The datatype of the result is the datatype with higher
 precedence.
 </div></div><div style="display: block; height: 2em;"></div>
<div id="s-1__log___"></div><div class="card"><pre class="card_header_code">Tensor&lt;to_float&lt;T&gt;, 1&gt; <b>log</b>() </pre></div>
<br />
<div class="card"><div style="padding: 5px;">
 Takes the elementwise natural logarithm of this Tensor.
</div></div><div style="display: block; height: 2em;"></div>
<div id="s-1__log2___"></div><div class="card"><pre class="card_header_code">Tensor&lt;to_float&lt;T&gt;, 1&gt; <b>log2</b>() </pre></div>
<br />
<div class="card"><div style="padding: 5px;">
 Takes the elementwise logarithm dualis of this Tensor.
</div></div><div style="display: block; height: 2em;"></div>
<div id="s-1__log10___"></div><div class="card"><pre class="card_header_code">Tensor&lt;to_float&lt;T&gt;, 1&gt; <b>log10</b>() </pre></div>
<br />
<div class="card"><div style="padding: 5px;">
 Takes the elementwise logarithm to basis 10 of this Tensor.
</div></div><div style="display: block; height: 2em;"></div>
<div id="s-1__sqrt___"></div><div class="card"><pre class="card_header_code">Tensor&lt;to_float&lt;T&gt;, 1&gt; <b>sqrt</b>() </pre></div>
<br />
<div class="card"><div style="padding: 5px;">
 Takes the elementwise square root of this Tensor.
</div></div><div style="display: block; height: 2em;"></div>
<div id="s-1__sin___"></div><div class="card"><pre class="card_header_code">Tensor&lt;to_float&lt;T&gt;, 1&gt; <b>sin</b>() </pre></div>
<br />
<div class="card"><div style="padding: 5px;">
 Takes the elementwise sinus of this Tensor.
</div></div><div style="display: block; height: 2em;"></div>
<div id="s-1__cos___"></div><div class="card"><pre class="card_header_code">Tensor&lt;to_float&lt;T&gt;, 1&gt; <b>cos</b>() </pre></div>
<br />
<div class="card"><div style="padding: 5px;">
 Takes the elementwise cosinus of this Tensor.
</div></div><div style="display: block; height: 2em;"></div>
<div id="s-1__tan___"></div><div class="card"><pre class="card_header_code">Tensor&lt;to_float&lt;T&gt;, 1&gt; <b>tan</b>() </pre></div>
<br />
<div class="card"><div style="padding: 5px;">
 Takes the elementwise tangents of this Tensor.
</div></div><div style="display: block; height: 2em;"></div>
<div id="s-1__asin___"></div><div class="card"><pre class="card_header_code">Tensor&lt;to_float&lt;T&gt;, 1&gt; <b>asin</b>() </pre></div>
<br />
<div class="card"><div style="padding: 5px;">
 Takes the elementwise arcsinus of this Tensor (<pre class="inline_code">sin^(-1)</pre>).
</div></div><div style="display: block; height: 2em;"></div>
<div id="s-1__acos___"></div><div class="card"><pre class="card_header_code">Tensor&lt;to_float&lt;T&gt;, 1&gt; <b>acos</b>() </pre></div>
<br />
<div class="card"><div style="padding: 5px;">
 Takes the elementwise arccosinus of this Tensor (<pre class="inline_code">cos^(-1)</pre>).
</div></div><div style="display: block; height: 2em;"></div>
<div id="s-1__atan___"></div><div class="card"><pre class="card_header_code">Tensor&lt;to_float&lt;T&gt;, 1&gt; <b>atan</b>() </pre></div>
<br />
<div class="card"><div style="padding: 5px;">
 Takes the elementwise arctangents of this Tensor (<pre class="inline_code">tan^(-1)</pre>).
</div></div><div style="display: block; height: 2em;"></div>
<div id="s-_typename_K__Tensor_K__1__convert___const_"></div><div class="card"><pre class="card_header_code">template &lt;typename K&gt; Tensor&lt;K, 1&gt; <b>convert</b>() const </pre></div>
<br />
<div class="card"><div style="padding: 5px;">
 Converts this Tensor (and the underlying data) to type <pre class="inline_code">K</pre> given in the
 template. <pre class="inline_code">K</pre> must be one of <pre class="inline_code">int</pre>, <pre class="inline_code">long</pre>, <pre class="inline_code">float</pre>, <pre class="inline_code">double</pre>. The data is
 converted, not reinterpreted.
</div></div><div style="display: block; height: 2em;"></div>
<div id="s-1__abs___const_"></div><div class="card"><pre class="card_header_code">Tensor&lt;T, 1&gt; <b>abs</b>() const </pre></div>
<br />
<div class="card"><div style="padding: 5px;">
 Takes the elementwise absolute value of this Tensor (negative signs are
 removed).
</div></div><div style="display: block; height: 2em;"></div>
<div id="s-_typename_K__unsigned_int_k___Tensor_int__k__operator__const_Tensor_K__k__&other__const_"></div><div class="card"><pre class="card_header_code">template &lt;typename K, unsigned int k&gt;
  Tensor&lt;int, k&gt; <b>operator&lt;</b>(const Tensor<K, k> &other) const </pre></div>
<br />
<div class="card"><div style="padding: 5px;">
 Compares this tensor and <pre class="inline_code">other</pre> elementwise and returns a 0,1 integer
 Tensor. <pre class="inline_code">0</pre> denotes that <pre class="inline_code">this &gt;= other</pre>, <pre class="inline_code">1</pre> that <pre class="inline_code">this &lt; other</pre> for that
 element.
</div></div><div style="display: block; height: 2em;"></div>
<div id="s-_typename_K__Tensor_int__1__operator__const_K_other__const_"></div><div class="card"><pre class="card_header_code">template &lt;typename K&gt; Tensor&lt;int, 1&gt; <b>operator&lt;</b>(const K other) const </pre></div>
<br />
<div class="card"><div style="padding: 5px;">
 Compares this tensor and the constant <pre class="inline_code">other</pre> elementwise and returns a 0,1
 integer Tensor. <pre class="inline_code">0</pre> denotes that <pre class="inline_code">this &gt;= other</pre>, <pre class="inline_code">1</pre> that <pre class="inline_code">this &lt; other</pre>
 for that element.
</div></div><div style="display: block; height: 2em;"></div>
<div id="s-_typename_K__unsigned_int_k___Tensor_int__1__operator__const_Tensor_K__k__&other__const_"></div><div class="card"><pre class="card_header_code">template &lt;typename K, unsigned int k&gt;
  Tensor&lt;int, 1&gt; <b>operator&gt;</b>(const Tensor<K, k> &other) const </pre></div>
<br />
<div class="card"><div style="padding: 5px;">
 Compares this tensor and <pre class="inline_code">other</pre> elementwise and returns a 0,1 integer
 Tensor. <pre class="inline_code">0</pre> denotes that <pre class="inline_code">this &lt;= other</pre>, <pre class="inline_code">1</pre> that <pre class="inline_code">this &gt; other</pre> for that
 element.
</div></div><div style="display: block; height: 2em;"></div>
<div id="s-_typename_K__Tensor_int__1__operator__const_K_other__const_"></div><div class="card"><pre class="card_header_code">template &lt;typename K&gt; Tensor&lt;int, 1&gt; <b>operator&gt;</b>(const K other) const </pre></div>
<br />
<div class="card"><div style="padding: 5px;">
 Compares this tensor and the constant <pre class="inline_code">other</pre> elementwise and returns a 0,1
 integer Tensor. <pre class="inline_code">0</pre> denotes that <pre class="inline_code">this &lt;= other</pre>, <pre class="inline_code">1</pre> that <pre class="inline_code">this &gt; other</pre>
 for that element.
</div></div><div style="display: block; height: 2em;"></div>
<div id="s-_typename_K__unsigned_int_k___Tensor_int__k__equal_const_Tensor_K__k__&other__const_"></div><div class="card"><pre class="card_header_code">template &lt;typename K, unsigned int k&gt;
  Tensor&lt;int, k&gt; <b>equal</b>(const Tensor<K, k> &other) const </pre></div>
<br />
<div class="card"><div style="padding: 5px;">
 Compares this tensor and <pre class="inline_code">other</pre> elementwise and returns a 0,1 integer
 Tensor. <pre class="inline_code">0</pre> denotes that <pre class="inline_code">this != other</pre>, <pre class="inline_code">1</pre> that <pre class="inline_code">this == other</pre>.
</div></div><div style="display: block; height: 2em;"></div>
<div id="s-_typename_K__Tensor_int__1__equal_const_K_other__const_"></div><div class="card"><pre class="card_header_code">template &lt;typename K&gt; Tensor&lt;int, 1&gt; <b>equal</b>(const K other) const </pre></div>
<br />
<div class="card"><div style="padding: 5px;">
 Compares this tensor and the constant <pre class="inline_code">other</pre> elementwise and returns a 0,1
 integer Tensor. <pre class="inline_code">0</pre> denotes that <pre class="inline_code">this != other</pre>, <pre class="inline_code">1</pre> that <pre class="inline_code">this == other</pre>.
</div></div><div style="display: block; height: 2em;"></div>
<div id="s-1__slice_long_start_=_0__long_end_=_TensorRange::MAX_SCOPE______________________long_step_=_1__const_"></div><div class="card"><pre class="card_header_code">Tensor&lt;T, 1&gt; <b>slice</b>(long start = 0, long end = TensorRange::MAX_SCOPE,
                     long step = 1) const </pre></div>
<br />
<div class="card"><div style="padding: 5px;">
 Slices a selection of the Tensor beginning by <pre class="inline_code">start</pre> (inclusive), ending
 with <pre class="inline_code">end</pre> (exclusive) by a step size <pre class="inline_code">step</pre>. The step size may be negative
 in which case traversal order changes, therefor <pre class="inline_code">start &gt; end</pre> must hold
 (for forward traversal of course <pre class="inline_code">end &gt; start</pre>). E.g.<div style="display:block; height: 0.5em"></div>
 <pre class="card code" style="margin: 5px;">
 <span style="color: #FFF030">Tensor</span>&lt;<span style="color: #FFF030">int</span>, <span style="color: #30F0FF">1</span>&gt; a{<span style="color: #30F0FF">1</span>, <span style="color: #30F0FF">2</span>, <span style="color: #30F0FF">3</span>, <span style="color: #30F0FF">4</span>, <span style="color: #30F0FF">5</span>, <span style="color: #30F0FF">6</span>, <span style="color: #30F0FF">7</span>, <span style="color: #30F0FF">8</span>};
 std::cout &lt;&lt; (a.slice(<span style="color: #30F0FF">6</span>, <span style="color: #30F0FF">1</span>, -<span style="color: #30F0FF">2</span>))() &lt;&lt; std::endl;
 <span style="color: #D0D0D0">// Tensor&lt;INT32, shape: <span style="color: #30F0FF">3</span>&gt;([<span style="color: #30F0FF">7</span>, <span style="color: #30F0FF">5</span>, <span style="color: #30F0FF">3</span>])</span></pre><div style="display:block; height: 0.5em"></div>
 To help with indexing there is the value
 <pre class="inline_code">TensorRange::MAX_SCOPE</pre> which describes a index depending on the traversal
 order in that dimension (i.e. the sign of step):<ul><li>for forward traversel it denotes in start the shape of this Tensor -
   1 (which is the last element start can index) and for end the shape of
   this Tensor.
</li><li>for backward traversal it denotes in start 0 and in end the element
   before 0 (this is necessary since otherwise it would not be possible to
   just inverse a dimension without eliminating values).</li></ul>
</div></div><div style="display: block; height: 2em;"></div>
<div id="s-get_graph_node___const_"></div><div class="card"><pre class="card_header_code">FGraphNode <b>*get_graph_node</b>() const </pre></div>
<br />
<div class="card"><div style="padding: 5px;"> Returns the underlying <pre class="inline_code">FGraphNode</pre> for use with the C-Frontend. It is
 still memory managed by this Tensor instance, so be carefull about variable
 lifetimes. </div></div><div style="display: block; height: 2em;"></div>
<div id="s-1__repeat_int_repetitions__const_"></div><div class="card"><pre class="card_header_code">Tensor&lt;T, 1&gt; <b>repeat</b>(int repetitions) const </pre></div>
<br />
<div class="card"><div style="padding: 5px;">
 Repeats this Tensor <pre class="inline_code">repetitions</pre> times. A value of <pre class="inline_code">0</pre> would yield the
 input Tensor. E.g.<div style="display:block; height: 0.5em"></div>
 <pre class="card code" style="margin: 5px;">
 <span style="color: #FFF030">Tensor</span>&lt;<span style="color: #FFF030">int</span>, <span style="color: #30F0FF">1</span>&gt; a{<span style="color: #30F0FF">0</span>, <span style="color: #30F0FF">1</span>, -<span style="color: #30F0FF">1</span>};
 std::cout &lt;&lt; (a.repeat(<span style="color: #30F0FF">2</span>))() &lt;&lt; std::endl;
 <span style="color: #D0D0D0">// Tensor&lt;INT32, shape: <span style="color: #30F0FF">7</span>&gt;([<span style="color: #30F0FF">0</span>, <span style="color: #30F0FF">1</span>, -<span style="color: #30F0FF">1</span>, <span style="color: #30F0FF">0</span>, <span style="color: #30F0FF">1</span>, -<span style="color: #30F0FF">1</span>, <span style="color: #30F0FF">0</span>, <span style="color: #30F0FF">1</span>, -<span style="color: #30F0FF">1</span>])</span></pre>
</div></div><div style="display: block; height: 2em;"></div>
<div id="s-_typename_K__unsigned_int_k___Tensor_double__k__gradient_const_Tensor_K__k__&dx__"></div><div class="card"><pre class="card_header_code">template &lt;typename K, unsigned int k&gt;
  Tensor&lt;double, k&gt; <b>gradient</b>(const Tensor<K, k> &dx) </pre></div>
<br />
<div class="card"><div style="padding: 5px;">
 Calculates the gradient of this Tensor to <pre class="inline_code">dx</pre>. A gradient is always a
 Tensor of type <pre class="inline_code">double</pre>.
</div></div><div style="display: block; height: 2em;"></div>

    </div>
</center>
  <div id="footer">
    <center>
    <div class="content">
      <div class="row">
        <div class="column">
           David Schwarzbeck, 2022</br>
          Licensed under the <a href="https://github.com/Frobeniusnorm/Flint/blob/main/LICENCE">Apache License</a>, Version 2.0
        </div>
        <div class="column">&nbsp;</div>
        <div class="column">&nbsp;</div>
        <div class="column">
          <a href="https://github.com/Frobeniusnorm/Flint/">Github</a>
        </div>
      </div>
    </div>
    </center>
  </div>
</body>
</html>
